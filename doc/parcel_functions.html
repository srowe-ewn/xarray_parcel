<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>parcel_functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>parcel_functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># parcel_functions.py
#
# xarray-enabled versions of MetPy functions for atmospheric parcel calculations.
# 
# Author: Tim Raupach &lt;t.raupach@unsw.edu.au&gt;

import metpy
import xarray
import numpy as np
from metpy.units import units
import metpy.constants as mpconsts
        
def get_layer(dat, depth=100, drop=False, vert_dim=&#39;model_level_number&#39;, interpolate=True):
    &#34;&#34;&#34;
    Return an atmospheric layer from the surface with a given depth.

    Arguments:
      - dat: DataArray, must contain pressure.
      - depth: Depth above the bottom of the layer to mix [hPa].
      - drop: Drop unselected elements?
      - vert_dim: Vertical dimension name.
      - interpolate: Interpolate the bottom/top layers?

    Returns:

      - xarray DataArray with pressure and data variables for the layer.
    &#34;&#34;&#34;
       
    # Use the surface (lowest level) pressure as the bottom pressure.
    bottom_pressure = dat.pressure.max(dim=vert_dim)
        
    # Calculate top pressure.
    if interpolate:
        top_pressure = bottom_pressure-depth
        interp_level = log_interp(x=dat, at=top_pressure, 
                                  coords=dat.pressure, dim=vert_dim)
        interp_level[&#39;pressure&#39;] = top_pressure
        dat = insert_level(d=dat, level=interp_level, coords=&#39;pressure&#39;, vert_dim=vert_dim)
    else:
        top_pressure = bound_pressure(pressure=dat.pressure, 
                                      bound=bottom_pressure-depth, 
                                      vert_dim=vert_dim)
        
    # Select the layer.
    layer = dat.where(dat.pressure &lt;= bottom_pressure, drop=drop)
    layer = dat.where(dat.pressure &gt;= top_pressure, drop=drop)
    
    return layer

def most_unstable_parcel(dat, depth=300, drop=False, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Return the most unstable parcel with an atmospheric layer from with the 
    requested bottom and depth. No interpolation is performed.

    Arguments:
        - dat: DataArray, must contain pressure, temperature, and dewpoint.
        - bottom: Pressure level to start from [hPa].
        - depth: Depth above the bottom of the layer to mix [hPa].
        - drop: Drop unselected elements?
        - vert_dim: Vertical dimension name.

    Returns:

        - xarray DataArray with pressure and data variables for the layer.
    &#34;&#34;&#34;

    layer = get_layer(dat=dat, depth=depth, drop=drop, vert_dim=vert_dim, interpolate=False)
    eq = metpy.calc.equivalent_potential_temperature(pressure=layer.pressure,
                                                     temperature=layer.temperature,
                                                     dewpoint=layer.dewpoint).metpy.dequantify()
    max_eq = eq.max(dim=vert_dim)
    assert np.all(eq.where(eq == max_eq).count(vert_dim) == 1), &#39;Multiple maximum eq values.&#39;
    most_unstable = layer.where(eq == max_eq).max(dim=vert_dim, keep_attrs=True)
    return most_unstable
    
def mixed_layer(dat, depth=100, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Mix variable(s) over a layer, yielding a mass-weighted average.

    Integrate a data variable with respect to pressure and determine the
    average value using the mean value theorem.

    Arguments:
        - dat: The DataArray to mix. Must contain pressure and variables.
        - bottom: Pressure above the surface pressure to start from [hPa].
        - depth: Depth above the bottom of the layer to mix [hPa].
        - vert_dim: The name of the vertical dimension.

    Returns:

        - xarray with mixed values of each data variable.
    &#34;&#34;&#34;
    
    layer = get_layer(dat=dat, depth=depth, drop=True)
    
    pressure_depth = np.abs(layer.pressure.min(vert_dim) - 
                            layer.pressure.max(vert_dim))
   
    ret = (1. / pressure_depth) * trapz(dat=layer, x=&#39;pressure&#39;, dim=vert_dim)
    return ret
    
def trapz(dat, x, dim, mask=None):
    &#34;&#34;&#34; 
    Perform trapezoidal rule integration along an axis, ala numpy.trapz.
    Estimates int y dx.
   
    Arguments:
        - dat: Data to process.
        - x: The variable that contains &#39;x&#39; values along dimension &#39;dim&#39;.
        - dim: The dimension along which to integrate &#39;y&#39; values.
        - mask: A mask the size of dx/means (ie dim.size-1) for which 
                areas to include in the integration.

    Returns:

        - Integrated value along the axis.
    &#34;&#34;&#34;

    dx = np.abs(dat[x].diff(dim))
    dx = dx.reset_coords(drop=True)
    means = dat.rolling({dim: 2}, center=True).mean(keep_attrs=True).dropna(dim, how=&#39;all&#39;)
    means = means.reset_coords(drop=True)

    dx = dx.assign_coords({dim: dx[dim]-1})
    means = means.assign_coords({dim: means[dim]-1})
    
    if mask is not None:
        dx = dx.where(mask)
        means = means.where(mask)
    
    return (dx * means).sum(dim)
    
def bound_pressure(pressure, bound, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the bounding pressure in a layer; returns the closest pressure to the bound.
    
    Arguments:
        - pressure: Atmospheric pressures [hPa].
        - bound: Bound to retrieve, broadcastable to pressure [hPa].

    Returns:

        - The bound pressures.
    &#34;&#34;&#34;
    
    diffs = np.abs(pressure - bound)
    bounds = pressure.where(diffs == diffs.min(dim=vert_dim), drop=True)
    assert bounds[vert_dim].size == 1, &#39;Pressure field contains duplicates.&#39;
    bounds = bounds.squeeze(drop=True)
    return bounds

def mixed_parcel(pressure, temperature, dewpoint, depth=100, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Fully mix a layer of given depth above the surface and find the temparature, 
    pressure and dewpoint of the parcel.

    Arguments:
        - pressure: Pressure by level [hPa].
        - temperature: Temperature at each level [K].
        - dewpoint: Dewpoint at each level [K].
        - depth: Depth above the surface to mix [hPa].
        - vert_dim: The name of the vertical dimension.

    Returns:

        - DataArray with mixed parcel pressure [hPa], temperature [K] and dewpoint [K].
    &#34;&#34;&#34;
    
    # Use the surface (lowest level) pressure as the start of the layer to mix.
    parcel_start_pressure = pressure.isel({vert_dim: 0})

    # Calculate the potential temperature over the layer.
    theta = metpy.calc.potential_temperature(pressure, temperature)
    theta = theta.metpy.dequantify()
    theta.name = &#39;theta&#39;
    
    # Mixing ratio over the layer.
    mixing_ratio = metpy.calc.saturation_mixing_ratio(pressure, dewpoint)
    mixing_ratio = mixing_ratio.metpy.dequantify()
    mixing_ratio.name = &#39;mixing_ratio&#39;
    
    # Mix theta and mixing ratio over the layer.
    assert pressure.name is not None, &#39;pressure requires name pressure.&#39;
    mp = mixed_layer(xarray.merge([pressure, theta, mixing_ratio]), depth=depth)
        
    # Convert potential temperature back to temperature.
    mp[&#39;temperature&#39;] = mp.theta * metpy.calc.exner_function(parcel_start_pressure)
    mp[&#39;temperature&#39;] = mp.temperature.metpy.dequantify()
    mp.temperature.attrs[&#39;long_name&#39;] = &#39;Mixed parcel temperature&#39;
    mp.temperature.attrs[&#39;units&#39;] = &#39;K&#39;

    # Convert mixing ratio back to dewpoint.
    mp[&#39;vapour_pressure&#39;] = metpy.calc.vapor_pressure(parcel_start_pressure, mp.mixing_ratio)
    mp[&#39;vapour_pressure&#39;] = mp.vapour_pressure.metpy.dequantify()
    mp.vapour_pressure.attrs[&#39;long_name&#39;] = &#39;Mixed-parcel vapour pressure&#39;
    
    mp[&#39;dewpoint&#39;] = metpy.calc.dewpoint(mp.vapour_pressure).metpy.convert_units(&#39;K&#39;)
    mp[&#39;dewpoint&#39;] = mp.dewpoint.metpy.dequantify()
    mp.dewpoint.attrs[&#39;long_name&#39;] = &#39;Mixed-parcel dewpoint&#39;
    
    # For pressure, use the starting pressure for the layer (following MetPy&#39;s 
    # mixed_parcel function).
    mp[&#39;pressure&#39;] = parcel_start_pressure 
    
    return mp

def dry_lapse(pressure, parcel_temperature, parcel_pressure=None, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the temperature of a parcel raised dry-adiabatically (conserving
    potential temperature).

    Arguments:
        -pressure: Atmospheric pressure level(s) of interest [hPa].
        -parcel_temperature: Parcel temperature before lifting (constant or broadcast-able DataArray).
        - parcel_pressure: Parcel pressure(s) before lifting. Defaults to vertical maximum.
        - vert_dim: The name of the vertical dimension.

    Returns:

        - Parcel temperature at each pressure level.
    &#34;&#34;&#34;
    
    if parcel_pressure is None:
        parcel_pressure = pressure.max(vert_dim)
    out = parcel_temperature * (pressure / parcel_pressure)**mpconsts.kappa
    out.attrs[&#39;long_name&#39;] = &#39;Dry lapse rate temperature&#39;
    out.attrs[&#39;units&#39;] = &#39;K&#39;
    return out

def moist_adiabat_tables(regenerate=False, cache=True,
                         lookup_cache=&#39;lookup_tables/moist_adiabat_lookup.nc&#39;,
                         adiabats_cache=&#39;lookup_tables/adiabats_cache.nc&#39;,
                         **kwargs):
    &#34;&#34;&#34;
    Calculate moist adiabat lookup tables.
    
    Arguments:
        - regenerate: Calculate from scratch and save caches?
        - cache: Write cache files?
        - lookup_cache: A cache file (nc) for the adiabat lookup table.
        - adiabats_cache: A cache file (nc) for the adiabats cache.
        - **kwargs: Keyword arguments to moist_adiabat_lookup().
                           
    Returns:

        - two DataArrays: 1) a lookup table of pressure/temperature vs. adiabat number, 
             and 2) a lookup table of adiabat number to temperature by pressure profiles.
    &#34;&#34;&#34;
    
    if not regenerate:
        adiabat_lookup = xarray.open_dataset(lookup_cache)
        adiabats = xarray.open_dataset(adiabats_cache)
        return adiabat_lookup, adiabats
    
    # Generate lookup tables.
    adiabat_lookup, adiabats = moist_adiabat_lookup(**kwargs)
    
    if cache:
        adiabats.to_netcdf(adiabats_cache)
        adiabat_lookup.to_netcdf(lookup_cache)
        
    return adiabat_lookup, adiabats

def round_to(x, to, dp=2):
    &#34;&#34;&#34;
    Round x to the nearest &#39;to&#39; and return rounded to &#39;dp&#39; decimal points.
    &#34;&#34;&#34;
    return np.round(np.round(x / to) * to, dp)

def moist_adiabat_lookup(pressure_levels=np.round(np.arange(1100, 0, step=-0.5), 1),
                         temperatures=np.round(np.arange(173, 316, step=0.02), 2),
                         pres_step=0.5, temp_step=0.02):
    &#34;&#34;&#34;
    Calculate moist adiabat lookup tables.
    
    Arguments:
        - pressure_levels: Pressure levels to keep in adiabat lookup table [hPa].
        - temperatures: Temperatures to keep in adiabat lookup table [K].
        - pres_step, temp_step: (Positive) step size for pressure_levels and 
                              temperatures, respectively.
                              
    Returns:
        - two DataArrays: 1) a lookup table of pressure/temperature vs. adiabat number, 
             and 2) a lookup table of adiabat number to temperature by pressure profiles.
    &#34;&#34;&#34;
        
    curves = []
    adiabat_lookup = xarray.Dataset({&#39;adiabat&#39;: np.nan})
    adiabat_lookup = adiabat_lookup.expand_dims({&#39;pressure&#39;: pressure_levels, 
                                                 &#39;temperature&#39;: temperatures}).copy(deep=True)
    
    # Find the adiabat for each starting temperature.
    i = 1
    for parcel_temperature in temperatures:
        for offset in [0, temp_step/2]:
            profile_temps = metpy.calc.moist_lapse(pressure=pressure_levels*units.hPa, 
                                                   temperature=(parcel_temperature+offset)*units.K).m

            nearest_temps = round_to(profile_temps, temp_step)
            idx = np.isin(nearest_temps, temperatures)
            temp_idx = xarray.DataArray(nearest_temps[idx], dims=[&#39;idx&#39;])
            pres_idx = xarray.DataArray(pressure_levels[idx], dims=[&#39;idx&#39;])
            adiabat_lookup.adiabat.loc[{&#39;pressure&#39;:pres_idx, &#39;temperature&#39;: temp_idx}] = i

            # In profile_temps we have the adiabat temperature for every pressure level.
            # But some temperatures in the lookup table may be missing. Interpolate the 
            # pressures for each required temperature.
            pres_per_temp = np.interp(x=temperatures, xp=profile_temps[::-1], 
                                      fp=pressure_levels[::-1], right=np.nan, left=np.nan)

            pres_per_temp = round_to(pres_per_temp, pres_step)
            idx = np.isin(pres_per_temp, pressure_levels)
            pres_idx = xarray.DataArray(pres_per_temp[idx], dims=[&#39;idx&#39;])
            temp_idx = xarray.DataArray(temperatures[idx], dims=[&#39;idx&#39;])
            adiabat_lookup.adiabat.loc[{&#39;pressure&#39;:pres_idx, &#39;temperature&#39;: temp_idx}] = i

            # curves contains the adiabats themselves.
            curves.append(xarray.Dataset({&#39;temperature&#39;: ([&#39;pressure&#39;], profile_temps)}, 
                                         coords={&#39;pressure&#39;: pressure_levels}))
            curves[-1][&#39;adiabat&#39;] = i
            i = i + 1

    # Combine curves into one dataset.
    adiabats = xarray.combine_nested(curves, concat_dim=&#39;adiabat&#39;)
        
    for x in [adiabat_lookup, adiabats]:
        x.pressure.attrs[&#39;long_name&#39;] = &#39;Pressure&#39;
        x.pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
        x.temperature.attrs[&#39;long_name&#39;] = &#39;Temperature&#39;
        x.temperature.attrs[&#39;units&#39;] = &#39;K&#39;
        x.adiabat.attrs[&#39;long_name&#39;] = &#39;Adiabat index&#39;
        
    return adiabat_lookup, adiabats

def moist_lapse(pressure, parcel_temperature, moist_adiabat_lookup, moist_adiabats,
                parcel_pressure=None, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Return the temperature of parcels raised moist-adiabatically (assuming liquid saturation processes).
    Note: What is returned are approximate pseudo-adiabatic moist lapse rates, found using a lookup table.

    Arguments:
        - pressure: Atmospheric pressure(s) to lift the parcel to [hPa].
        - parcel_temperature: Temperature(s) of parcels to lift [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by moist_adiabat_tables().
        - parcel_pressure: Parcel pressure before lifting. Defaults to vertical maximum.
        - vert_dim: The name of the vertical dimension.

    Returns:

        - Parcel temperature at each pressure level.
    &#34;&#34;&#34;

    if parcel_pressure is None:
        parcel_pressure = pressure.max(vert_dim)
        
    # For each starting parcel, find the moist adiabat that intersects the parcel pressure 
    # and temperature.
    adiabat_idx = moist_adiabat_lookup.sel({&#39;pressure&#39;: parcel_pressure, 
                                            &#39;temperature&#39;: parcel_temperature}, method=&#39;nearest&#39;)
    adiabat_idx = adiabat_idx.adiabat.reset_coords(drop=True)
    adiabats = moist_adiabats.sel(adiabat=adiabat_idx)
    
    # Interpolate the adiabat to get the temperature at each requested pressure.
    out = adiabats.temperature.interp({&#39;pressure&#39;: pressure}).reset_coords(drop=True)
    return out

def lcl(parcel_pressure, parcel_temperature, parcel_dewpoint):
    &#34;&#34;&#34;
    Return the lifting condensation level for parcels.
    
    Arguments:
        - parcel_pressure: Pressure of the parcel to lift [hPa].
        - parcel_temperature: Parcel temperature [K].
        - parfel_dewpoint: Parcel dewpoint [K].
    
    Returns:

        - A Dataset with lcl_pressure and lcl_temperature.
    &#34;&#34;&#34;
    
    press_lcl, temp_lcl = metpy.calc.lcl(pressure=parcel_pressure, 
                                         temperature=parcel_temperature, 
                                         dewpoint=parcel_dewpoint)
    out = xarray.Dataset({&#39;lcl_pressure&#39;: (parcel_temperature.dims, press_lcl.m),
                          &#39;lcl_temperature&#39;: (parcel_temperature.dims, temp_lcl.m)})
    
    out.lcl_pressure.attrs[&#39;long_name&#39;] = &#39;Lifting condensation level pressure&#39;
    out.lcl_pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
    out.lcl_temperature.attrs[&#39;long_name&#39;] = &#39;Lifting condensation level temperature&#39;
    out.lcl_temperature.attrs[&#39;units&#39;] = &#39;K&#39;
    
    return out

def parcel_profile(pressure, parcel_pressure, parcel_temperature, parcel_dewpoint, 
                   moist_adiabat_lookup, moist_adiabats):
    &#34;&#34;&#34;
    Calculate temperatures of a lifted parcel.
    
    Arguments:
        - pressure: Pressure levels to calculate on [hPa].
        - parcel_pressure: Pressure of the parcel [hPa].
        - parcel_temperature: Temperature of the parcel [K].
        - parcel_dewpoint: Dewpoint of the parcel [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by moist_adiabat_tables().
  
    Returns:

        - Dataset with the temperature of the parcel lifted from parcel_pressure to 
          levels in pressures, plus the LCL pressure and temperature.
    &#34;&#34;&#34;
       
    out = xarray.Dataset()
    out[&#39;pressure&#39;] = pressure

    # Find the LCL for the selected parcel.
    out = xarray.merge([out, lcl(parcel_pressure=parcel_pressure, 
                                 parcel_temperature=parcel_temperature, 
                                 parcel_dewpoint=parcel_dewpoint)])

    # Parcels are raised along the dry adiabats from the starting point to the LCL.
    below_lcl = dry_lapse(pressure=pressure, 
                          parcel_temperature=parcel_temperature, 
                          parcel_pressure=parcel_pressure)

    # Above the LCL parcels follow the moist adiabats from the LCL temp/pressure.
    above_lcl = moist_lapse(pressure=pressure, 
                            parcel_temperature=out.lcl_temperature,
                            parcel_pressure=out.lcl_pressure,
                            moist_adiabat_lookup=moist_adiabat_lookup,
                            moist_adiabats=moist_adiabats)

    out[&#39;temperature&#39;] = below_lcl.where(pressure &gt;= out.lcl_pressure, other=above_lcl)
    out.temperature.attrs[&#39;long_name&#39;] = &#39;Lifted parcel temperature&#39;
    out.temperature.attrs[&#39;units&#39;] = &#39;K&#39;

    out = out.reset_coords(drop=True)
    return out

def parcel_profile_with_lcl(pressure, temperature, parcel_pressure, parcel_temperature, 
                            parcel_dewpoint, moist_adiabat_lookup, moist_adiabats,
                            vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate temperatures of a lifted parcel, including at the lcl.
    
    Arguments:
        - pressure: Pressure levels to calculate on [hPa].
        - temperature: Temperature at each pressure level [K].
        - parcel_pressure: Pressure of the parcel [hPa].
        - parcel_temperature: Temperature of the parcel [K].
        - parcel_dewpoint: Dewpoint of the parcel [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                              moist_adiabat_tables().
        - vert_dim: The name of the vertical dimension.
  
    Returns:

         - Dataset with the temperature of the parcel lifted from parcel_pressure to 
             levels in pressures, including the LCL, plus the LCL pressure and temperature, and
             environmental temperature including at the LCL.
    &#34;&#34;&#34;
    
    profile = parcel_profile(pressure=pressure, parcel_pressure=parcel_pressure, 
                             parcel_temperature=parcel_temperature,
                             parcel_dewpoint=parcel_dewpoint, 
                             moist_adiabat_lookup=moist_adiabat_lookup, 
                             moist_adiabats=moist_adiabats)
    return add_lcl_to_profile(profile=profile, vert_dim=vert_dim, temperature=temperature)

def add_lcl_to_profile(profile, vert_dim=&#39;model_level_number&#39;, temperature=None):
    &#34;&#34;&#34;
    Add the LCL to a profile.
    
    Arguments:
        - profile: Profile as returned from parcel_profile().
        - vert_dim: The vertical dimension to add the LCL pressure/temp to.
        - temperature: Environmental temperatures. If provided, interpolate environment 
                       temperature for the LCL and return as &#39;env_temperature&#39;.
        
    Returns:

        - A new profile object with LCL pressure and temperatures added. Note the 
        vertical coordinate in the new profile is reindexed.
    &#34;&#34;&#34;
    
    level = xarray.Dataset({&#39;pressure&#39;: profile.lcl_pressure,
                            &#39;temperature&#39;: profile.lcl_temperature})
    out = insert_level(d=profile, level=level, coords=&#39;pressure&#39;, vert_dim=vert_dim)
    out[&#39;lcl_pressure&#39;] = profile.lcl_pressure
    out[&#39;lcl_temperature&#39;] = profile.lcl_temperature
    out.temperature.attrs[&#39;long_name&#39;] = &#39;Temperature with LCL&#39;
    out.pressure.attrs[&#39;long_name&#39;]  = &#39;Pressure with LCL&#39;

    if not temperature is None:
        environment = xarray.Dataset({&#39;temperature&#39;: temperature,
                                      &#39;pressure&#39;: profile.pressure})
        temp_at_level = xarray.Dataset({&#39;temperature&#39;: linear_interp(x=temperature, 
                                                                     coords=profile.pressure,
                                                                     at=level.pressure, 
                                                                     dim=vert_dim),
                                        &#39;pressure&#39;: level.pressure})

        environment = insert_level(d=environment, level=temp_at_level, 
                                   coords=&#39;pressure&#39;, vert_dim=vert_dim)
        out[&#39;environment_temperature&#39;] = environment.temperature
        out.environment_temperature.attrs[&#39;long_name&#39;] = &#39;Environment temperature&#39;
        out.environment_temperature.attrs[&#39;units&#39;] = &#39;K&#39;
    
    return out

def insert_level(d, level, coords, vert_dim=&#39;model_level_number&#39;, fill_value=-999):
    &#34;&#34;&#34;
    Insert a new level into a vertically sorted dataset.
    
    Arguments:
        - d: The data to work on.
        - coords: The coordinate name in d.
        - level: The new values to add; a single layer with values for &#39;coord&#39; 
               and any other variables to add.
        - vert_dim: The vertical dimension to add new level to.
        
    Returns:

        - A new object with the new level added.
             Note the vertical coordinate in the new profile is reindexed.
    &#34;&#34;&#34;
    
    # To conserve nans in the original dataset, replace them with fill_value in
    # the coordinate array.
    #assert not np.any(d[coords] == fill_value), &#39;dataset d contains fill_value.&#39;
    d = d.where(np.logical_not(np.isnan(d[coords])), other=fill_value)
    
    below = d.where(d[coords] &gt; level[coords])
    above = d.where(d[coords] &lt; level[coords])
       
    # Above the new coordinate, shift the vertical coordinate indices up one.
    above = above.assign_coords({vert_dim: d[vert_dim] + 1})

    # Use broadcasting to fills regions below the new coordinate.
    out, _ = xarray.broadcast(below, above)

    # Fill regions above the new coordinate.
    above, _ = xarray.broadcast(above, out)
    out = above.where(np.isnan(out[coords]), other=out)
    
    # Any remaining nan values must now be the new level, so fill those regions.
    new, _ = xarray.broadcast(level, out)
  
    # Subset to keys from new only.
    out = out[list(new.keys())]
    out = new.where(np.isnan(out), other=out)
    
    # Replace fill_value with nans.
    out = out.where(out != fill_value, other=np.nan)
        
    return out

def find_intersections(x, a, b, dim, log_x=False):
    &#34;&#34;&#34;
    Find intersections of two lines that share x coordinates.
    
    Arguments:
        - x: The shared x coordinate values.
        - a: y values for line 1.
        - b: y values for line 2.
        - dim: The dimension along which the coordinates are indexed.
        - log_x: Use a logarithmic transform on x coordinates (e.g. for pressure coords)?
        
    Returns:

        - Dataset containing x, y coordinates for all intersections, 
             increasing intersections and decreasing intersections. Note duplicates 
             are not removed.
    &#34;&#34;&#34;

    if log_x:
        x = np.log(x)

    # Find intersections. Non-zero points in diffs indicates an intersection.
    diffs = np.sign(a - b).diff(dim=dim)
    
    # Identify the points after each intersection.
    after_intersects = diffs.where(diffs == 0, other=1)
    
    # And the points just before each intersection.s
    before_intersects = xarray.concat([xarray.zeros_like(a.isel({dim: 0})), 
                                       after_intersects], dim=dim)
    before_intersects = before_intersects.shift({dim: -1}, fill_value=0)
    
    # The sign of the change for the intersect.
    sign_change = np.sign(a.where(after_intersects == 1) - b.where(after_intersects == 1))

    x0 = x.where(before_intersects == 1).shift({dim: 1})
    x1 = x.where(after_intersects == 1)
    a0 = a.where(before_intersects == 1).shift({dim: 1})
    a1 = a.where(after_intersects == 1)
    b0 = b.where(before_intersects == 1).shift({dim: 1})
    b1 = b.where(after_intersects == 1) 

    # Calculate the x-intersection. This comes from finding the equations of the two lines,
    # one through (x0, a0) and (x1, a1) and the other through (x0, b0) and (x1, b1),
    # finding their intersection, and reducing with a bunch of algebra.
    delta_y0 = a0 - b0
    delta_y1 = a1 - b1
    intersect_x = (delta_y1 * x0 - delta_y0 * x1) / (delta_y1 - delta_y0)

    # Calculate the y-intersection of the lines. Just plug the x above into the equation
    # for the line through the a points.
    intersect_y = ((intersect_x - x0) / (x1 - x0)) * (a1 - a0) + a0

    if log_x is True:
        intersect_x = np.exp(intersect_x)

    out = xarray.Dataset()
    out[&#39;all_intersect_x&#39;] = intersect_x
    out[&#39;all_intersect_y&#39;] = intersect_y
    out[&#39;increasing_x&#39;] = intersect_x.where(sign_change &gt; 0)
    out[&#39;increasing_y&#39;] = intersect_y.where(sign_change &gt; 0)
    out[&#39;decreasing_x&#39;] = intersect_x.where(sign_change &lt; 0)
    out[&#39;decreasing_y&#39;] = intersect_y.where(sign_change &lt; 0)
    out = out.rename({dim: &#39;offset_dim&#39;})

    return out

def lfc_el(profile, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the level of free convection (LFC) and equilibrium level (EL). 
    
    Works by finding the first intersection of the ideal parcel path and the measured parcel 
    temperature. If this intersection occurs below the LCL, the LFC is determined to be the 
    same as the LCL, based upon the conditions set forth in [USAF1990]_, pg 4-14, where a 
    parcel must be lifted dry adiabatically to saturation before it can freely rise.
    The LFC returned is the &#39;bottom&#39; LFC with highest pressure; the EL returned is the 
    &#39;top&#39; EL with the lowest pressure.

    Arguments:
        - profile: The parcel profile, including the LCL, as returned from 
                   parcel_profile_with_lcl().
        - vert_dim: Vertical dimension name in input arrays.
    
    Returns:

        - DataArray with LFC pressure (lfc_pressure) and temperature (lfc_temperature).
    &#34;&#34;&#34;
    
    # Find all intersections between parcel and environmental temperatures by pressure.
    intersections = find_intersections(x=profile.pressure, a=profile.temperature, 
                                       b=profile.environment_temperature, 
                                       dim=vert_dim, log_x=True)

    # Find intersections again, ignoring first level.
    intersections_above = find_intersections(x=profile.pressure.isel({vert_dim: slice(1,None)}),
                                             a=profile.temperature.isel({vert_dim: slice(1,None)}), 
                                             b=profile.environment_temperature.isel({vert_dim: slice(1,None)}), 
                                             dim=vert_dim, log_x=True).reindex_like(intersections)
    
    # For points for which the atmosphere and parcel temperatures have the same lowest-level value, 
    # ignore this point and find the real LFC above it.
    intersections = intersections.where((profile.environment_temperature.isel({vert_dim: 0}) != 
                                         profile.temperature.isel({vert_dim: 0})),
                                        other=intersections_above)

    out = xarray.Dataset()
    
    # By default the first values are the lowest (highest pressure) crossings for LFC and 
    # the highest (lowest pressure) crossings for EL. The LFC also has to be above the LCL.
    above_lcl = intersections.increasing_x &lt; profile.lcl_pressure
        
    out[&#39;lfc_pressure&#39;] = intersections.increasing_x.where(above_lcl).max(dim=&#39;offset_dim&#39;)
    out[&#39;lfc_temperature&#39;] = intersections.increasing_y.where(intersections.increasing_x == 
                                                              out.lfc_pressure).max(dim=&#39;offset_dim&#39;)
    
    # Determine equilibrium pressure and temperature. The &#39;top&#39; (lowest pressure) EL is returned.
    out[&#39;el_pressure&#39;] = intersections_above.decreasing_x.min(dim=&#39;offset_dim&#39;)
    out[&#39;el_temperature&#39;] = intersections_above.decreasing_y.where(intersections.decreasing_x == 
                                                                   out.el_pressure).max(dim=&#39;offset_dim&#39;)
    
    # If at the top of the atmosphere the parcel profile is warmer than the environment,
    # no EL exists. Also if EL is lower than or equal to LCL, no EL exists.
    top_pressure = profile.pressure == profile.pressure.min(dim=vert_dim)
    top_prof_temp = profile.temperature.where(top_pressure).max(dim=vert_dim)
    top_env_temp = profile.environment_temperature.where(top_pressure).max(dim=vert_dim)
    
    top_colder = top_prof_temp &lt;= top_env_temp
    el_above_lcl = out.el_pressure &lt; profile.lcl_pressure
    el_exists = np.logical_and(top_colder, el_above_lcl)
    out[&#39;el_pressure&#39;] = out.el_pressure.where(el_exists, other=np.nan)
    out[&#39;el_temperature&#39;] = out.el_temperature.where(el_exists, other=np.nan)
    
    # There should only be one LFC and EL per point.
    assert not &#39;offset_dim&#39; in out.keys(), &#39;Error, duplicate crossings detected.&#39;

    # Identify points where no LFC intersections were found.
    lfc_missing = np.isnan(intersections.increasing_x.max(dim=&#39;offset_dim&#39;))

    # If no intersection was found, but a parcel temperature above the LCL is greater than the
    # environmental temperature, return the LCL.
    above_lcl = profile.pressure &lt; profile.lcl_pressure
    pos_parcel = ((profile.temperature.where(above_lcl) &gt; 
                   profile.environment_temperature.where(above_lcl)).any(dim=vert_dim))
    no_lfc_pos_parcel = np.logical_and(pos_parcel, lfc_missing)

    # Also return LCL if an intersection exists but all intersections are below the LCL
    # and EL is above the LCL.
    exists_but_na = np.logical_and(np.logical_not(lfc_missing), np.isnan(out.lfc_pressure))
    el_above_lcl = out.el_pressure &lt; profile.lcl_pressure
    lfc_below_el_above = np.logical_and(exists_but_na, el_above_lcl)
    
    # Do the replacements with LCL.
    replace_with_lcl = np.logical_or(no_lfc_pos_parcel, lfc_below_el_above)
    out[&#39;lfc_pressure&#39;] = profile.lcl_pressure.where(replace_with_lcl, other=out.lfc_pressure)
    out[&#39;lfc_temperature&#39;] = profile.lcl_temperature.where(replace_with_lcl, other=out.lfc_temperature)   
    
    # Assign metadata.
    out.el_pressure.attrs[&#39;long_name&#39;] = &#39;Equilibrium level pressure&#39;
    out.el_pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
    out.el_temperature.attrs[&#39;long_name&#39;] = &#39;Equilibrium level temperature&#39;
    out.el_temperature.attrs[&#39;units&#39;] = &#39;K&#39;
    out.lfc_pressure.attrs[&#39;long_name&#39;] = &#39;Level of free convection pressure&#39;
    out.lfc_pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
    out.lfc_temperature.attrs[&#39;long_name&#39;] = &#39;Level of free convection temperature&#39;
    out.lfc_temperature.attrs[&#39;units&#39;] = &#39;K&#39;

    return out

def trap_around_zeros(x, y, dim, log_x=True, start=0):
    &#34;&#34;&#34;
    Calculate dx * y for points just before and after zeros in y.
    
    Arguments:
        - x: arrays of x along dim.
        - y: arrays of y along dim.
        - dim: Dimension along which to calculate.
        - log_x: Log transform x?
        - start: Zero-based position along dim to look for zeros.
        
    Returns:

        - a Dataset containin the areas and x coordinates for each rectangular area 
          calculated before and after each zero; and an array of x coordinates that should be 
          replaced by the new areas if integrating along x and including these areas afterwards.
    &#34;&#34;&#34;
    
    # Estimate zero crossings.
    zeros = xarray.zeros_like(y)
    zero_intersections = find_intersections(x=x.isel({dim: slice(start, None)}), 
                                            a=y.isel({dim: slice(start, None)}),
                                            b=zeros.isel({dim: slice(start, None)}),
                                            dim=dim, log_x=log_x)
    zero_intersections = zero_intersections.rename({&#39;offset_dim&#39;: dim})
    zero_y = zero_intersections.all_intersect_y
    zero_x = zero_intersections.all_intersect_x
        
    # Take log of x if required.
    if log_x:
        x = np.log(x)
        zero_x = np.log(zero_x)
    
    zero_level = xarray.zeros_like(y.isel({dim: 0}))
    
    after_zeros_mask = np.logical_not(np.isnan(zero_y))
    before_zeros_mask = xarray.concat([zero_level, zero_y], dim=dim).shift({dim: -1})
    before_zeros_mask = np.logical_not(np.isnan(before_zeros_mask))
    
    def calc_areas(x, y, mask, shift_x=0):
        areas = xarray.Dataset({&#39;area&#39;: xarray.zeros_like(mask),
                                &#39;dx&#39;: xarray.zeros_like(mask),
                                &#39;x&#39;: xarray.zeros_like(mask)})

        # Get coordinates of zeros.
        x_near_zero = x.where(mask)
        y_near_zero = y.where(mask)
        
        # Determine the value of y (mean of y and zero) and dx.
        mean_y = y_near_zero / 2
        
        dx = x_near_zero.shift({dim:shift_x}) - zero_x
        dx = xarray.concat([zero_level, dx], dim=dim).shift({dim: -shift_x})
    
        areas[&#39;area&#39;] = mean_y * np.abs(dx)
        areas[&#39;x&#39;] = x_near_zero - dx/2
        areas[&#39;dx&#39;] = np.abs(dx)
        areas = areas.dropna(dim=dim, how=&#39;all&#39;).reset_coords(drop=True)
        
        return(areas)
        
    areas_before_zeros = calc_areas(x=x, y=y, mask=before_zeros_mask, shift_x=1)
    areas_after_zeros = calc_areas(x=x, y=y, mask=after_zeros_mask, shift_x=0)
   
    # Concatenate areas before zeros and areas after zeros.
    areas = xarray.concat([areas_before_zeros, areas_after_zeros], dim=dim)
    #areas = areas.assign_coords({dim: np.arange(0, len(areas[dim]))})
    
    # Determine start/end points on x axis for each area.
    areas[&#39;x_from&#39;] = areas.x - areas.dx/2
    areas[&#39;x_to&#39;] = areas.x + areas.dx/2
    
    # Mask is a mask that selects elements that were *not* included in the differences;
    # to be used by a CAPE calculation where we don&#39;t want to count the areas around
    # zeros twice.
    mask = xarray.full_like(x, True)
    mask, bef = xarray.broadcast(mask, areas_before_zeros)
    mask = mask.where(np.isnan(bef.area), other=False)
    
    return areas, mask
   
def cape_cin_base(pressure, temperature, lfc_pressure, el_pressure, parcel_profile, 
                  vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate CAPE and CIN.

    Calculate the convective available potential energy (CAPE) and convective inhibition (CIN)
    of a given upper air profile and parcel path. CIN is integrated between the surface and
    LFC, CAPE is integrated between the LFC and EL (or top of sounding). Intersection points
    of the measured temperature profile and parcel profile are logarithmically interpolated.
    
    Uses the bottom (highest-pressure) LFC and the top (lowest-pressure) EL.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - lfc_pressure: Pressure of level of free convection [hPa].
        - el_pressure: Pressure of equilibrium level [hPa].
        - parcel_profile: The parcel profile as returned from parcel_profile().
        - vert_dim: The vertical dimension.

    Returns:
        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;

    # Where the EL is nan, use the highest (lowest-pressure) value as the EL.
    el_pressure = pressure.min(dim=vert_dim).where(np.isnan(el_pressure), 
                                                   other=el_pressure)

    # Difference between the parcel path and measured temperature profiles.
    temp_diffs = xarray.Dataset({&#39;temp_diff&#39;: (parcel_profile.temperature - temperature),
                                 &#39;pressure&#39;: pressure,
                                 &#39;log_pressure&#39;: np.log(pressure)})
    
    # Integration areas around zero differences. Note MetPy&#39;s implementation 
    # in _find_append_zero_crossings() looks for intersections from the 2nd 
    # index onward (start=1 in this code); but in this implemnetation the 
    # whole array needs to be checked (start=0) for the unit tests to pass.
    areas_around_zeros, trapz_mask = trap_around_zeros(x=temp_diffs.pressure, 
                                                       y=temp_diffs.temp_diff,  
                                                       dim=vert_dim, log_x=True)
    areas_around_zeros[&#39;x&#39;] = np.exp(areas_around_zeros.x)
    areas_around_zeros[&#39;x_from&#39;] = np.exp(areas_around_zeros.x_from)
    areas_around_zeros[&#39;x_to&#39;] = np.exp(areas_around_zeros.x_to)
     
    # Integrate between LFC and EL pressure levels to get CAPE.
    diffs_lfc_to_el = temp_diffs.where(pressure &lt;= lfc_pressure)
    diffs_lfc_to_el = diffs_lfc_to_el.where(pressure &gt;= el_pressure)
    areas_lfc_to_el = areas_around_zeros.where(areas_around_zeros.x &lt;= lfc_pressure)
    areas_lfc_to_el = areas_lfc_to_el.where(areas_around_zeros.x &gt;= el_pressure)
    
    cape = mpconsts.Rd.m * trapz(dat=diffs_lfc_to_el, x=&#39;log_pressure&#39;, 
                                 dim=vert_dim, mask=trapz_mask)
    cape = cape.reset_coords().temp_diff
    cape = cape + (mpconsts.Rd.m * areas_lfc_to_el.area.sum(dim=vert_dim))
    cape.name = &#39;cape&#39;
    cape.attrs[&#39;long_name&#39;] = &#39;Convective available potential energy&#39;
    cape.attrs[&#39;units&#39;] = &#39;J kg-1&#39;

    # Integrate between surface and LFC to get CIN.
    temp_diffs_surf_to_lfc = temp_diffs.where(pressure &gt;= lfc_pressure)
    areas_surf_to_lfc = areas_around_zeros.where(areas_around_zeros.x &gt;= lfc_pressure)
    cin = mpconsts.Rd.m * trapz(dat=temp_diffs_surf_to_lfc, x=&#39;log_pressure&#39;, 
                                dim=vert_dim, mask=trapz_mask)
    cin = cin.reset_coords().temp_diff
    cin = cin + (mpconsts.Rd.m * areas_surf_to_lfc.area.sum(dim=vert_dim))
    cin.name = &#39;cin&#39;
    cin.attrs[&#39;long_name&#39;] = &#39;Convective inhibition&#39;
    cin.attrs[&#39;units&#39;] = &#39;J kg-1&#39;

    # Set any positive values for CIN to 0.
    cin = cin.where(cin &lt;= 0, other=0)

    return xarray.merge([cape, cin])

def cape_cin(pressure, temperature, parcel_temperature, parcel_pressure, parcel_dewpoint,
             moist_adiabat_lookup, moist_adiabats, vert_dim=&#39;model_level_number&#39;, 
             return_profile=False):
    &#34;&#34;&#34;
    Calculate CAPE and CIN; wraps finding of LFC and parcel profile and call to 
    cape_cin_base. Uses the bottom (highest-pressure) LFC and the top (lowest-pressure) EL.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - parcel_temperature: The temperature of the starting parcel [K].
        - parcel_pressure: The pressure of the starting parcel [K].
        - parcel_dewpoint: The dewpoint of the starting parcel [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - vert_dim: The vertical dimension.
        - return_profile: Also return the lifted profile?

    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1, plus the lifted profile if 
          return_profile is True.
    &#34;&#34;&#34;
    
    # Calculate parcel profile.
    profile = parcel_profile_with_lcl(pressure=pressure,
                                      temperature=temperature,
                                      parcel_temperature=parcel_temperature,
                                      parcel_pressure=parcel_pressure,
                                      parcel_dewpoint=parcel_dewpoint,
                                      moist_adiabat_lookup=moist_adiabat_lookup, 
                                      moist_adiabats=moist_adiabats, 
                                      vert_dim=vert_dim)
    
    # Calculate LFC and EL.
    parcel_lfc_el = lfc_el(profile=profile)
    
    # Calculate CAPE and CIN.
    cape_cin = cape_cin_base(pressure=profile.pressure,
                             temperature=profile.environment_temperature, 
                             lfc_pressure=parcel_lfc_el.lfc_pressure, 
                             el_pressure=parcel_lfc_el.el_pressure, 
                             parcel_profile=profile)
    
    if return_profile:
        return cape_cin, profile
    else:
        return cape_cin
    
def surface_based_cape_cin(pressure, temperature, dewpoint, moist_adiabat_lookup, 
                           moist_adiabats, vert_dim=&#39;model_level_number&#39;, return_profile=False):
    &#34;&#34;&#34;
    Calculate surface-based CAPE and CIN.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - dewpoint: Dewpoint at each level [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - vert_dim: The vertical dimension.
        - return_profile: Also return the lifted profile?
        
    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;
    
    # Profile for surface-based parcel ascent.
    return cape_cin(pressure=pressure,
                    temperature=temperature,
                    parcel_temperature=temperature.isel({vert_dim: 0}),
                    parcel_pressure=pressure.isel({vert_dim: 0}),
                    parcel_dewpoint=dewpoint.isel({vert_dim: 0}),
                    moist_adiabat_lookup=moist_adiabat_lookup, 
                    moist_adiabats=moist_adiabats,
                    vert_dim=vert_dim,
                    return_profile=return_profile)

def most_unstable_cape_cin(pressure, temperature, dewpoint, moist_adiabat_lookup, moist_adiabats, 
                           vert_dim=&#39;model_level_number&#39;, depth=300, return_profile=False):
    &#34;&#34;&#34;
    Calculate CAPE and CIN for the most unstable parcel within a given 
    depth above the surface..

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - dewpoint: Dewpoint at each level [K].
        - vert_dim: The vertical dimension.
        - depth: The depth above the surface (lowest-level pressure) in which to 
                 look for the most unstable parcel.
        - return_profile: Also return the lifted profile?
        
    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;
    
    assert pressure.name == &#39;pressure&#39;, &#39;Pressure requires name pressure.&#39;
    assert temperature.name == &#39;temperature&#39;, &#39;Temperature requires name temperature.&#39;
    assert dewpoint.name == &#39;dewpoint&#39;, &#39;Dewpoint requires name dewpoint.&#39;
        
    # Find the most unstable layer in the lowest &#39;depth&#39; hPa.
    unstable_layer = most_unstable_parcel(dat=xarray.merge([pressure, temperature, dewpoint]), 
                                          depth=depth, vert_dim=vert_dim)
        
    # Subset to layers at or above the most unstable parcels.
    above_unstable = pressure &lt;= unstable_layer.pressure
    pressure = shift_out_nans(pressure.where(above_unstable, drop=True), dim=vert_dim)
    temperature = shift_out_nans(temperature.where(above_unstable, drop=True), dim=vert_dim)
        
    return cape_cin(pressure=pressure,
                    temperature=temperature,
                    parcel_temperature=unstable_layer.temperature, 
                    parcel_pressure=unstable_layer.pressure,
                    parcel_dewpoint=unstable_layer.dewpoint,
                    moist_adiabat_lookup=moist_adiabat_lookup, 
                    moist_adiabats=moist_adiabats,
                    vert_dim=vert_dim,
                    return_profile=return_profile)    
        
def mixed_layer_cape_cin(pressure, temperature, dewpoint, moist_adiabat_lookup, moist_adiabats, 
                         vert_dim=&#39;model_level_number&#39;, depth=100, return_profile=False):
    &#34;&#34;&#34;
    Calculate CAPE and CIN for a fully-mixed lowest x hPa parcel.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - dewpoint: Dewpoint at each level [K].
        - vert_dim: The vertical dimension.
        - depth: The depth above the surface (lowest-level pressure) to mix [hPa].
        - return_profile: Also return the lifted profile?
        
    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;

    # Mix the lowest x hPa.
    mp = mixed_parcel(pressure=pressure, temperature=temperature, 
                      dewpoint=dewpoint, depth=depth)
    
    # Remove layers that were part of the mixed layer.
    higher_levels = pressure &lt; (pressure.max(dim=vert_dim) - depth)
    pressure = shift_out_nans(pressure.where(higher_levels, drop=True), dim=vert_dim)
    temperature = shift_out_nans(temperature.where(higher_levels, drop=True), dim=vert_dim)
    
    # Add the mixed layer to the bottom of the profiles.
    mp[vert_dim] = pressure[vert_dim].min() - 1
    pressure = xarray.concat([mp.pressure, pressure], dim=vert_dim)
    temperature = xarray.concat([mp.temperature, temperature], dim=vert_dim)
        
    return cape_cin(pressure=pressure,
                    temperature=temperature,
                    parcel_temperature=mp.temperature, 
                    parcel_pressure=mp.pressure,
                    parcel_dewpoint=mp.dewpoint,
                    moist_adiabat_lookup=moist_adiabat_lookup, 
                    moist_adiabats=moist_adiabats, 
                    vert_dim=vert_dim,
                    return_profile=return_profile)
        
def shift_out_nans(x, dim, pt=0):
    &#34;&#34;&#34;
    Shift data along a dim to remove all leading nans in that dimension, element-wise.
    
    Arguments:
        - x: The data to work on.
        - dim: The dimension to shift.
        - pt: The point along the dimension to shift &#39;to&#39;.
    &#34;&#34;&#34;
    
    while np.any(np.isnan(x.isel({dim: pt}))):
        shifted = x.shift({dim: -1})
        x = shifted.where(np.isnan(x.isel({dim: pt})), other=x)
        
    return x

def lifted_index(profile, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the lifted index. 
    
    Lifted index formula derived from Galway 1956 and referenced by DoswellSchultz 2006.

    Arguments:
        - profile: Profile as returned by parcel_profile_with_lcl().
        - vert_dim: The vertical dimension name.

    Returns:

        - Lifted index at each point [K].
    &#34;&#34;&#34;
    
    # Interpolate (linearly) to get 500 hPa values.
    dat = linear_interp(x=profile, coords=profile.pressure, at=500, dim=vert_dim)
    dat = dat.reset_coords(drop=True)
    
    # Calculate lifted index.
    li = xarray.Dataset({&#39;lifted_index&#39;: dat.environment_temperature - dat.temperature})
    li.lifted_index.attrs[&#39;long_name&#39;] = &#39;Lifted index&#39;
    li.lifted_index.attrs[&#39;units&#39;] = &#39;K&#39;
    
    return li
    
def linear_interp(x, coords, at, dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Perform simple linear interpolation to get values at specified points.
    
    Arguments:
        x: Data set to interpolate.
        coords: Coordinate value for each point in x.
        at: Points at which to interpolate.
        dim: The dimension along which to interpolate.
    
    It is assumed that x[coords] is sorted and does not contain duplicate 
    values along the selected dimension.
    &#34;&#34;&#34;
    
    coords_before = coords.where(coords &gt;= at).min(dim=dim)
    coords_after = coords.where(coords &lt;= at).max(dim=dim)
    assert dim not in coords_before.coords, &#39;Duplicates detected in coords.&#39;
    assert dim not in coords_after.coords, &#39;Duplicates detected in coords.&#39;

    x_before = x.where(coords == coords_before).max(dim=dim)
    x_after = x.where(coords == coords_after).max(dim=dim)

    # The interpolated values.
    res = x_before + (x_after - x_before) * ((at - coords_before) / (coords_after - coords_before))
    
    # When the interpolated x exists already, return it.
    res = x_before.where(x_before == x_after, other=res)
    
    return(res)

def log_interp(x, coords, at, dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Run linear_interp on logged coordinate values.
    
    Arguments:
        - x: Data set to interpolate.
        - coords: Coordinate value for each point in x.
        - at: Points at which to interpolate.
        - dim: The dimension along which to interpolate.
    
    It is assumed that x[coords] is sorted and does not contain duplicate 
    values along the selected dimension.
    &#34;&#34;&#34;
    
    return linear_interp(x=x, coords=np.log(coords), at=np.log(at), dim=dim)
    
def deep_convective_index(pressure, temperature, dewpoint, lifted_index, 
                          vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the deep convective index (DCI) as defined by Kunz 2009.
    
    Arguments:
        - pressure: Pressure values [hPa].
        - temperature: Temperature at each pressure [K].
        - dewpoint: Dewpoint temperature at each pressure.
        - lifted_index: The lifted index.
        - vert_dim: The vertical dimension name.
    
    Returns:

        - The DCI [C] per point.
    &#34;&#34;&#34;
    
    dat = xarray.merge([pressure, temperature, dewpoint])
    
    # Interpolate (linearly) to get 850 hPa values.
    dat = linear_interp(x=dat, coords=dat.pressure, at=850, dim=vert_dim)
    dat = dat.reset_coords(drop=True)
    
    # Convert temperature and dewpoint from K to C.
    dat[&#39;temperature&#39;] = dat.temperature - 273.15
    dat[&#39;dewpoint&#39;] = dat.dewpoint - 273.15
    
    dci = xarray.Dataset({&#39;dci&#39;: dat.temperature + dat.dewpoint - lifted_index})
    dci.dci.attrs[&#39;long_name&#39;] = &#39;Deep convective index&#39;
    dci.dci.attrs[&#39;units&#39;] = &#39;C&#39;
    return dci
 </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="parcel_functions.add_lcl_to_profile"><code class="name flex">
<span>def <span class="ident">add_lcl_to_profile</span></span>(<span>profile, vert_dim='model_level_number', temperature=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the LCL to a profile.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>profile: Profile as returned from parcel_profile().</li>
<li>vert_dim: The vertical dimension to add the LCL pressure/temp to.</li>
<li>temperature: Environmental temperatures. If provided, interpolate environment
temperature for the LCL and return as 'env_temperature'.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>A new profile object with LCL pressure and temperatures added. Note the
vertical coordinate in the new profile is reindexed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lcl_to_profile(profile, vert_dim=&#39;model_level_number&#39;, temperature=None):
    &#34;&#34;&#34;
    Add the LCL to a profile.
    
    Arguments:
        - profile: Profile as returned from parcel_profile().
        - vert_dim: The vertical dimension to add the LCL pressure/temp to.
        - temperature: Environmental temperatures. If provided, interpolate environment 
                       temperature for the LCL and return as &#39;env_temperature&#39;.
        
    Returns:

        - A new profile object with LCL pressure and temperatures added. Note the 
        vertical coordinate in the new profile is reindexed.
    &#34;&#34;&#34;
    
    level = xarray.Dataset({&#39;pressure&#39;: profile.lcl_pressure,
                            &#39;temperature&#39;: profile.lcl_temperature})
    out = insert_level(d=profile, level=level, coords=&#39;pressure&#39;, vert_dim=vert_dim)
    out[&#39;lcl_pressure&#39;] = profile.lcl_pressure
    out[&#39;lcl_temperature&#39;] = profile.lcl_temperature
    out.temperature.attrs[&#39;long_name&#39;] = &#39;Temperature with LCL&#39;
    out.pressure.attrs[&#39;long_name&#39;]  = &#39;Pressure with LCL&#39;

    if not temperature is None:
        environment = xarray.Dataset({&#39;temperature&#39;: temperature,
                                      &#39;pressure&#39;: profile.pressure})
        temp_at_level = xarray.Dataset({&#39;temperature&#39;: linear_interp(x=temperature, 
                                                                     coords=profile.pressure,
                                                                     at=level.pressure, 
                                                                     dim=vert_dim),
                                        &#39;pressure&#39;: level.pressure})

        environment = insert_level(d=environment, level=temp_at_level, 
                                   coords=&#39;pressure&#39;, vert_dim=vert_dim)
        out[&#39;environment_temperature&#39;] = environment.temperature
        out.environment_temperature.attrs[&#39;long_name&#39;] = &#39;Environment temperature&#39;
        out.environment_temperature.attrs[&#39;units&#39;] = &#39;K&#39;
    
    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.bound_pressure"><code class="name flex">
<span>def <span class="ident">bound_pressure</span></span>(<span>pressure, bound, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the bounding pressure in a layer; returns the closest pressure to the bound.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Atmospheric pressures [hPa].</li>
<li>bound: Bound to retrieve, broadcastable to pressure [hPa].</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>The bound pressures.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bound_pressure(pressure, bound, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the bounding pressure in a layer; returns the closest pressure to the bound.
    
    Arguments:
        - pressure: Atmospheric pressures [hPa].
        - bound: Bound to retrieve, broadcastable to pressure [hPa].

    Returns:

        - The bound pressures.
    &#34;&#34;&#34;
    
    diffs = np.abs(pressure - bound)
    bounds = pressure.where(diffs == diffs.min(dim=vert_dim), drop=True)
    assert bounds[vert_dim].size == 1, &#39;Pressure field contains duplicates.&#39;
    bounds = bounds.squeeze(drop=True)
    return bounds</code></pre>
</details>
</dd>
<dt id="parcel_functions.cape_cin"><code class="name flex">
<span>def <span class="ident">cape_cin</span></span>(<span>pressure, temperature, parcel_temperature, parcel_pressure, parcel_dewpoint, moist_adiabat_lookup, moist_adiabats, vert_dim='model_level_number', return_profile=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate CAPE and CIN; wraps finding of LFC and parcel profile and call to
cape_cin_base. Uses the bottom (highest-pressure) LFC and the top (lowest-pressure) EL.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure level(s) of interest [hPa].</li>
<li>temperature: Temperature at each pressure level [K].</li>
<li>parcel_temperature: The temperature of the starting parcel [K].</li>
<li>parcel_pressure: The pressure of the starting parcel [K].</li>
<li>parcel_dewpoint: The dewpoint of the starting parcel [K].</li>
<li>moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by
moist_adiabat_tables().</li>
<li>vert_dim: The vertical dimension.</li>
<li>return_profile: Also return the lifted profile?</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset with convective available potential energy (cape) and
convective inhibition (cin), both in J kg-1, plus the lifted profile if
return_profile is True.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cape_cin(pressure, temperature, parcel_temperature, parcel_pressure, parcel_dewpoint,
             moist_adiabat_lookup, moist_adiabats, vert_dim=&#39;model_level_number&#39;, 
             return_profile=False):
    &#34;&#34;&#34;
    Calculate CAPE and CIN; wraps finding of LFC and parcel profile and call to 
    cape_cin_base. Uses the bottom (highest-pressure) LFC and the top (lowest-pressure) EL.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - parcel_temperature: The temperature of the starting parcel [K].
        - parcel_pressure: The pressure of the starting parcel [K].
        - parcel_dewpoint: The dewpoint of the starting parcel [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - vert_dim: The vertical dimension.
        - return_profile: Also return the lifted profile?

    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1, plus the lifted profile if 
          return_profile is True.
    &#34;&#34;&#34;
    
    # Calculate parcel profile.
    profile = parcel_profile_with_lcl(pressure=pressure,
                                      temperature=temperature,
                                      parcel_temperature=parcel_temperature,
                                      parcel_pressure=parcel_pressure,
                                      parcel_dewpoint=parcel_dewpoint,
                                      moist_adiabat_lookup=moist_adiabat_lookup, 
                                      moist_adiabats=moist_adiabats, 
                                      vert_dim=vert_dim)
    
    # Calculate LFC and EL.
    parcel_lfc_el = lfc_el(profile=profile)
    
    # Calculate CAPE and CIN.
    cape_cin = cape_cin_base(pressure=profile.pressure,
                             temperature=profile.environment_temperature, 
                             lfc_pressure=parcel_lfc_el.lfc_pressure, 
                             el_pressure=parcel_lfc_el.el_pressure, 
                             parcel_profile=profile)
    
    if return_profile:
        return cape_cin, profile
    else:
        return cape_cin</code></pre>
</details>
</dd>
<dt id="parcel_functions.cape_cin_base"><code class="name flex">
<span>def <span class="ident">cape_cin_base</span></span>(<span>pressure, temperature, lfc_pressure, el_pressure, parcel_profile, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate CAPE and CIN.</p>
<p>Calculate the convective available potential energy (CAPE) and convective inhibition (CIN)
of a given upper air profile and parcel path. CIN is integrated between the surface and
LFC, CAPE is integrated between the LFC and EL (or top of sounding). Intersection points
of the measured temperature profile and parcel profile are logarithmically interpolated.</p>
<p>Uses the bottom (highest-pressure) LFC and the top (lowest-pressure) EL.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure level(s) of interest [hPa].</li>
<li>temperature: Temperature at each pressure level [K].</li>
<li>lfc_pressure: Pressure of level of free convection [hPa].</li>
<li>el_pressure: Pressure of equilibrium level [hPa].</li>
<li>parcel_profile: The parcel profile as returned from parcel_profile().</li>
<li>vert_dim: The vertical dimension.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset with convective available potential energy (cape) and
convective inhibition (cin), both in J kg-1.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cape_cin_base(pressure, temperature, lfc_pressure, el_pressure, parcel_profile, 
                  vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate CAPE and CIN.

    Calculate the convective available potential energy (CAPE) and convective inhibition (CIN)
    of a given upper air profile and parcel path. CIN is integrated between the surface and
    LFC, CAPE is integrated between the LFC and EL (or top of sounding). Intersection points
    of the measured temperature profile and parcel profile are logarithmically interpolated.
    
    Uses the bottom (highest-pressure) LFC and the top (lowest-pressure) EL.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - lfc_pressure: Pressure of level of free convection [hPa].
        - el_pressure: Pressure of equilibrium level [hPa].
        - parcel_profile: The parcel profile as returned from parcel_profile().
        - vert_dim: The vertical dimension.

    Returns:
        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;

    # Where the EL is nan, use the highest (lowest-pressure) value as the EL.
    el_pressure = pressure.min(dim=vert_dim).where(np.isnan(el_pressure), 
                                                   other=el_pressure)

    # Difference between the parcel path and measured temperature profiles.
    temp_diffs = xarray.Dataset({&#39;temp_diff&#39;: (parcel_profile.temperature - temperature),
                                 &#39;pressure&#39;: pressure,
                                 &#39;log_pressure&#39;: np.log(pressure)})
    
    # Integration areas around zero differences. Note MetPy&#39;s implementation 
    # in _find_append_zero_crossings() looks for intersections from the 2nd 
    # index onward (start=1 in this code); but in this implemnetation the 
    # whole array needs to be checked (start=0) for the unit tests to pass.
    areas_around_zeros, trapz_mask = trap_around_zeros(x=temp_diffs.pressure, 
                                                       y=temp_diffs.temp_diff,  
                                                       dim=vert_dim, log_x=True)
    areas_around_zeros[&#39;x&#39;] = np.exp(areas_around_zeros.x)
    areas_around_zeros[&#39;x_from&#39;] = np.exp(areas_around_zeros.x_from)
    areas_around_zeros[&#39;x_to&#39;] = np.exp(areas_around_zeros.x_to)
     
    # Integrate between LFC and EL pressure levels to get CAPE.
    diffs_lfc_to_el = temp_diffs.where(pressure &lt;= lfc_pressure)
    diffs_lfc_to_el = diffs_lfc_to_el.where(pressure &gt;= el_pressure)
    areas_lfc_to_el = areas_around_zeros.where(areas_around_zeros.x &lt;= lfc_pressure)
    areas_lfc_to_el = areas_lfc_to_el.where(areas_around_zeros.x &gt;= el_pressure)
    
    cape = mpconsts.Rd.m * trapz(dat=diffs_lfc_to_el, x=&#39;log_pressure&#39;, 
                                 dim=vert_dim, mask=trapz_mask)
    cape = cape.reset_coords().temp_diff
    cape = cape + (mpconsts.Rd.m * areas_lfc_to_el.area.sum(dim=vert_dim))
    cape.name = &#39;cape&#39;
    cape.attrs[&#39;long_name&#39;] = &#39;Convective available potential energy&#39;
    cape.attrs[&#39;units&#39;] = &#39;J kg-1&#39;

    # Integrate between surface and LFC to get CIN.
    temp_diffs_surf_to_lfc = temp_diffs.where(pressure &gt;= lfc_pressure)
    areas_surf_to_lfc = areas_around_zeros.where(areas_around_zeros.x &gt;= lfc_pressure)
    cin = mpconsts.Rd.m * trapz(dat=temp_diffs_surf_to_lfc, x=&#39;log_pressure&#39;, 
                                dim=vert_dim, mask=trapz_mask)
    cin = cin.reset_coords().temp_diff
    cin = cin + (mpconsts.Rd.m * areas_surf_to_lfc.area.sum(dim=vert_dim))
    cin.name = &#39;cin&#39;
    cin.attrs[&#39;long_name&#39;] = &#39;Convective inhibition&#39;
    cin.attrs[&#39;units&#39;] = &#39;J kg-1&#39;

    # Set any positive values for CIN to 0.
    cin = cin.where(cin &lt;= 0, other=0)

    return xarray.merge([cape, cin])</code></pre>
</details>
</dd>
<dt id="parcel_functions.deep_convective_index"><code class="name flex">
<span>def <span class="ident">deep_convective_index</span></span>(<span>pressure, temperature, dewpoint, lifted_index, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the deep convective index (DCI) as defined by Kunz 2009.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure values [hPa].</li>
<li>temperature: Temperature at each pressure [K].</li>
<li>dewpoint: Dewpoint temperature at each pressure.</li>
<li>lifted_index: The lifted index.</li>
<li>vert_dim: The vertical dimension name.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>The DCI [C] per point.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deep_convective_index(pressure, temperature, dewpoint, lifted_index, 
                          vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the deep convective index (DCI) as defined by Kunz 2009.
    
    Arguments:
        - pressure: Pressure values [hPa].
        - temperature: Temperature at each pressure [K].
        - dewpoint: Dewpoint temperature at each pressure.
        - lifted_index: The lifted index.
        - vert_dim: The vertical dimension name.
    
    Returns:

        - The DCI [C] per point.
    &#34;&#34;&#34;
    
    dat = xarray.merge([pressure, temperature, dewpoint])
    
    # Interpolate (linearly) to get 850 hPa values.
    dat = linear_interp(x=dat, coords=dat.pressure, at=850, dim=vert_dim)
    dat = dat.reset_coords(drop=True)
    
    # Convert temperature and dewpoint from K to C.
    dat[&#39;temperature&#39;] = dat.temperature - 273.15
    dat[&#39;dewpoint&#39;] = dat.dewpoint - 273.15
    
    dci = xarray.Dataset({&#39;dci&#39;: dat.temperature + dat.dewpoint - lifted_index})
    dci.dci.attrs[&#39;long_name&#39;] = &#39;Deep convective index&#39;
    dci.dci.attrs[&#39;units&#39;] = &#39;C&#39;
    return dci</code></pre>
</details>
</dd>
<dt id="parcel_functions.dry_lapse"><code class="name flex">
<span>def <span class="ident">dry_lapse</span></span>(<span>pressure, parcel_temperature, parcel_pressure=None, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the temperature of a parcel raised dry-adiabatically (conserving
potential temperature).</p>
<h2 id="arguments">Arguments</h2>
<p>-pressure: Atmospheric pressure level(s) of interest [hPa].
-parcel_temperature: Parcel temperature before lifting (constant or broadcast-able DataArray).
- parcel_pressure: Parcel pressure(s) before lifting. Defaults to vertical maximum.
- vert_dim: The name of the vertical dimension.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Parcel temperature at each pressure level.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dry_lapse(pressure, parcel_temperature, parcel_pressure=None, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the temperature of a parcel raised dry-adiabatically (conserving
    potential temperature).

    Arguments:
        -pressure: Atmospheric pressure level(s) of interest [hPa].
        -parcel_temperature: Parcel temperature before lifting (constant or broadcast-able DataArray).
        - parcel_pressure: Parcel pressure(s) before lifting. Defaults to vertical maximum.
        - vert_dim: The name of the vertical dimension.

    Returns:

        - Parcel temperature at each pressure level.
    &#34;&#34;&#34;
    
    if parcel_pressure is None:
        parcel_pressure = pressure.max(vert_dim)
    out = parcel_temperature * (pressure / parcel_pressure)**mpconsts.kappa
    out.attrs[&#39;long_name&#39;] = &#39;Dry lapse rate temperature&#39;
    out.attrs[&#39;units&#39;] = &#39;K&#39;
    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.find_intersections"><code class="name flex">
<span>def <span class="ident">find_intersections</span></span>(<span>x, a, b, dim, log_x=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Find intersections of two lines that share x coordinates.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>x: The shared x coordinate values.</li>
<li>a: y values for line 1.</li>
<li>b: y values for line 2.</li>
<li>dim: The dimension along which the coordinates are indexed.</li>
<li>log_x: Use a logarithmic transform on x coordinates (e.g. for pressure coords)?</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset containing x, y coordinates for all intersections,
increasing intersections and decreasing intersections. Note duplicates
are not removed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_intersections(x, a, b, dim, log_x=False):
    &#34;&#34;&#34;
    Find intersections of two lines that share x coordinates.
    
    Arguments:
        - x: The shared x coordinate values.
        - a: y values for line 1.
        - b: y values for line 2.
        - dim: The dimension along which the coordinates are indexed.
        - log_x: Use a logarithmic transform on x coordinates (e.g. for pressure coords)?
        
    Returns:

        - Dataset containing x, y coordinates for all intersections, 
             increasing intersections and decreasing intersections. Note duplicates 
             are not removed.
    &#34;&#34;&#34;

    if log_x:
        x = np.log(x)

    # Find intersections. Non-zero points in diffs indicates an intersection.
    diffs = np.sign(a - b).diff(dim=dim)
    
    # Identify the points after each intersection.
    after_intersects = diffs.where(diffs == 0, other=1)
    
    # And the points just before each intersection.s
    before_intersects = xarray.concat([xarray.zeros_like(a.isel({dim: 0})), 
                                       after_intersects], dim=dim)
    before_intersects = before_intersects.shift({dim: -1}, fill_value=0)
    
    # The sign of the change for the intersect.
    sign_change = np.sign(a.where(after_intersects == 1) - b.where(after_intersects == 1))

    x0 = x.where(before_intersects == 1).shift({dim: 1})
    x1 = x.where(after_intersects == 1)
    a0 = a.where(before_intersects == 1).shift({dim: 1})
    a1 = a.where(after_intersects == 1)
    b0 = b.where(before_intersects == 1).shift({dim: 1})
    b1 = b.where(after_intersects == 1) 

    # Calculate the x-intersection. This comes from finding the equations of the two lines,
    # one through (x0, a0) and (x1, a1) and the other through (x0, b0) and (x1, b1),
    # finding their intersection, and reducing with a bunch of algebra.
    delta_y0 = a0 - b0
    delta_y1 = a1 - b1
    intersect_x = (delta_y1 * x0 - delta_y0 * x1) / (delta_y1 - delta_y0)

    # Calculate the y-intersection of the lines. Just plug the x above into the equation
    # for the line through the a points.
    intersect_y = ((intersect_x - x0) / (x1 - x0)) * (a1 - a0) + a0

    if log_x is True:
        intersect_x = np.exp(intersect_x)

    out = xarray.Dataset()
    out[&#39;all_intersect_x&#39;] = intersect_x
    out[&#39;all_intersect_y&#39;] = intersect_y
    out[&#39;increasing_x&#39;] = intersect_x.where(sign_change &gt; 0)
    out[&#39;increasing_y&#39;] = intersect_y.where(sign_change &gt; 0)
    out[&#39;decreasing_x&#39;] = intersect_x.where(sign_change &lt; 0)
    out[&#39;decreasing_y&#39;] = intersect_y.where(sign_change &lt; 0)
    out = out.rename({dim: &#39;offset_dim&#39;})

    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.get_layer"><code class="name flex">
<span>def <span class="ident">get_layer</span></span>(<span>dat, depth=100, drop=False, vert_dim='model_level_number', interpolate=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an atmospheric layer from the surface with a given depth.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>dat: DataArray, must contain pressure.</li>
<li>depth: Depth above the bottom of the layer to mix [hPa].</li>
<li>drop: Drop unselected elements?</li>
<li>vert_dim: Vertical dimension name.</li>
<li>interpolate: Interpolate the bottom/top layers?</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>xarray DataArray with pressure and data variables for the layer.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_layer(dat, depth=100, drop=False, vert_dim=&#39;model_level_number&#39;, interpolate=True):
    &#34;&#34;&#34;
    Return an atmospheric layer from the surface with a given depth.

    Arguments:
      - dat: DataArray, must contain pressure.
      - depth: Depth above the bottom of the layer to mix [hPa].
      - drop: Drop unselected elements?
      - vert_dim: Vertical dimension name.
      - interpolate: Interpolate the bottom/top layers?

    Returns:

      - xarray DataArray with pressure and data variables for the layer.
    &#34;&#34;&#34;
       
    # Use the surface (lowest level) pressure as the bottom pressure.
    bottom_pressure = dat.pressure.max(dim=vert_dim)
        
    # Calculate top pressure.
    if interpolate:
        top_pressure = bottom_pressure-depth
        interp_level = log_interp(x=dat, at=top_pressure, 
                                  coords=dat.pressure, dim=vert_dim)
        interp_level[&#39;pressure&#39;] = top_pressure
        dat = insert_level(d=dat, level=interp_level, coords=&#39;pressure&#39;, vert_dim=vert_dim)
    else:
        top_pressure = bound_pressure(pressure=dat.pressure, 
                                      bound=bottom_pressure-depth, 
                                      vert_dim=vert_dim)
        
    # Select the layer.
    layer = dat.where(dat.pressure &lt;= bottom_pressure, drop=drop)
    layer = dat.where(dat.pressure &gt;= top_pressure, drop=drop)
    
    return layer</code></pre>
</details>
</dd>
<dt id="parcel_functions.insert_level"><code class="name flex">
<span>def <span class="ident">insert_level</span></span>(<span>d, level, coords, vert_dim='model_level_number', fill_value=-999)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert a new level into a vertically sorted dataset.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>d: The data to work on.</li>
<li>coords: The coordinate name in d.</li>
<li>level: The new values to add; a single layer with values for 'coord'
and any other variables to add.</li>
<li>vert_dim: The vertical dimension to add new level to.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>A new object with the new level added.
Note the vertical coordinate in the new profile is reindexed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_level(d, level, coords, vert_dim=&#39;model_level_number&#39;, fill_value=-999):
    &#34;&#34;&#34;
    Insert a new level into a vertically sorted dataset.
    
    Arguments:
        - d: The data to work on.
        - coords: The coordinate name in d.
        - level: The new values to add; a single layer with values for &#39;coord&#39; 
               and any other variables to add.
        - vert_dim: The vertical dimension to add new level to.
        
    Returns:

        - A new object with the new level added.
             Note the vertical coordinate in the new profile is reindexed.
    &#34;&#34;&#34;
    
    # To conserve nans in the original dataset, replace them with fill_value in
    # the coordinate array.
    #assert not np.any(d[coords] == fill_value), &#39;dataset d contains fill_value.&#39;
    d = d.where(np.logical_not(np.isnan(d[coords])), other=fill_value)
    
    below = d.where(d[coords] &gt; level[coords])
    above = d.where(d[coords] &lt; level[coords])
       
    # Above the new coordinate, shift the vertical coordinate indices up one.
    above = above.assign_coords({vert_dim: d[vert_dim] + 1})

    # Use broadcasting to fills regions below the new coordinate.
    out, _ = xarray.broadcast(below, above)

    # Fill regions above the new coordinate.
    above, _ = xarray.broadcast(above, out)
    out = above.where(np.isnan(out[coords]), other=out)
    
    # Any remaining nan values must now be the new level, so fill those regions.
    new, _ = xarray.broadcast(level, out)
  
    # Subset to keys from new only.
    out = out[list(new.keys())]
    out = new.where(np.isnan(out), other=out)
    
    # Replace fill_value with nans.
    out = out.where(out != fill_value, other=np.nan)
        
    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.lcl"><code class="name flex">
<span>def <span class="ident">lcl</span></span>(<span>parcel_pressure, parcel_temperature, parcel_dewpoint)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the lifting condensation level for parcels.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>parcel_pressure: Pressure of the parcel to lift [hPa].</li>
<li>parcel_temperature: Parcel temperature [K].</li>
<li>parfel_dewpoint: Parcel dewpoint [K].</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>A Dataset with lcl_pressure and lcl_temperature.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lcl(parcel_pressure, parcel_temperature, parcel_dewpoint):
    &#34;&#34;&#34;
    Return the lifting condensation level for parcels.
    
    Arguments:
        - parcel_pressure: Pressure of the parcel to lift [hPa].
        - parcel_temperature: Parcel temperature [K].
        - parfel_dewpoint: Parcel dewpoint [K].
    
    Returns:

        - A Dataset with lcl_pressure and lcl_temperature.
    &#34;&#34;&#34;
    
    press_lcl, temp_lcl = metpy.calc.lcl(pressure=parcel_pressure, 
                                         temperature=parcel_temperature, 
                                         dewpoint=parcel_dewpoint)
    out = xarray.Dataset({&#39;lcl_pressure&#39;: (parcel_temperature.dims, press_lcl.m),
                          &#39;lcl_temperature&#39;: (parcel_temperature.dims, temp_lcl.m)})
    
    out.lcl_pressure.attrs[&#39;long_name&#39;] = &#39;Lifting condensation level pressure&#39;
    out.lcl_pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
    out.lcl_temperature.attrs[&#39;long_name&#39;] = &#39;Lifting condensation level temperature&#39;
    out.lcl_temperature.attrs[&#39;units&#39;] = &#39;K&#39;
    
    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.lfc_el"><code class="name flex">
<span>def <span class="ident">lfc_el</span></span>(<span>profile, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the level of free convection (LFC) and equilibrium level (EL). </p>
<p>Works by finding the first intersection of the ideal parcel path and the measured parcel
temperature. If this intersection occurs below the LCL, the LFC is determined to be the
same as the LCL, based upon the conditions set forth in [USAF1990]_, pg 4-14, where a
parcel must be lifted dry adiabatically to saturation before it can freely rise.
The LFC returned is the 'bottom' LFC with highest pressure; the EL returned is the
'top' EL with the lowest pressure.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>profile: The parcel profile, including the LCL, as returned from
parcel_profile_with_lcl().</li>
<li>vert_dim: Vertical dimension name in input arrays.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>DataArray with LFC pressure (lfc_pressure) and temperature (lfc_temperature).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lfc_el(profile, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the level of free convection (LFC) and equilibrium level (EL). 
    
    Works by finding the first intersection of the ideal parcel path and the measured parcel 
    temperature. If this intersection occurs below the LCL, the LFC is determined to be the 
    same as the LCL, based upon the conditions set forth in [USAF1990]_, pg 4-14, where a 
    parcel must be lifted dry adiabatically to saturation before it can freely rise.
    The LFC returned is the &#39;bottom&#39; LFC with highest pressure; the EL returned is the 
    &#39;top&#39; EL with the lowest pressure.

    Arguments:
        - profile: The parcel profile, including the LCL, as returned from 
                   parcel_profile_with_lcl().
        - vert_dim: Vertical dimension name in input arrays.
    
    Returns:

        - DataArray with LFC pressure (lfc_pressure) and temperature (lfc_temperature).
    &#34;&#34;&#34;
    
    # Find all intersections between parcel and environmental temperatures by pressure.
    intersections = find_intersections(x=profile.pressure, a=profile.temperature, 
                                       b=profile.environment_temperature, 
                                       dim=vert_dim, log_x=True)

    # Find intersections again, ignoring first level.
    intersections_above = find_intersections(x=profile.pressure.isel({vert_dim: slice(1,None)}),
                                             a=profile.temperature.isel({vert_dim: slice(1,None)}), 
                                             b=profile.environment_temperature.isel({vert_dim: slice(1,None)}), 
                                             dim=vert_dim, log_x=True).reindex_like(intersections)
    
    # For points for which the atmosphere and parcel temperatures have the same lowest-level value, 
    # ignore this point and find the real LFC above it.
    intersections = intersections.where((profile.environment_temperature.isel({vert_dim: 0}) != 
                                         profile.temperature.isel({vert_dim: 0})),
                                        other=intersections_above)

    out = xarray.Dataset()
    
    # By default the first values are the lowest (highest pressure) crossings for LFC and 
    # the highest (lowest pressure) crossings for EL. The LFC also has to be above the LCL.
    above_lcl = intersections.increasing_x &lt; profile.lcl_pressure
        
    out[&#39;lfc_pressure&#39;] = intersections.increasing_x.where(above_lcl).max(dim=&#39;offset_dim&#39;)
    out[&#39;lfc_temperature&#39;] = intersections.increasing_y.where(intersections.increasing_x == 
                                                              out.lfc_pressure).max(dim=&#39;offset_dim&#39;)
    
    # Determine equilibrium pressure and temperature. The &#39;top&#39; (lowest pressure) EL is returned.
    out[&#39;el_pressure&#39;] = intersections_above.decreasing_x.min(dim=&#39;offset_dim&#39;)
    out[&#39;el_temperature&#39;] = intersections_above.decreasing_y.where(intersections.decreasing_x == 
                                                                   out.el_pressure).max(dim=&#39;offset_dim&#39;)
    
    # If at the top of the atmosphere the parcel profile is warmer than the environment,
    # no EL exists. Also if EL is lower than or equal to LCL, no EL exists.
    top_pressure = profile.pressure == profile.pressure.min(dim=vert_dim)
    top_prof_temp = profile.temperature.where(top_pressure).max(dim=vert_dim)
    top_env_temp = profile.environment_temperature.where(top_pressure).max(dim=vert_dim)
    
    top_colder = top_prof_temp &lt;= top_env_temp
    el_above_lcl = out.el_pressure &lt; profile.lcl_pressure
    el_exists = np.logical_and(top_colder, el_above_lcl)
    out[&#39;el_pressure&#39;] = out.el_pressure.where(el_exists, other=np.nan)
    out[&#39;el_temperature&#39;] = out.el_temperature.where(el_exists, other=np.nan)
    
    # There should only be one LFC and EL per point.
    assert not &#39;offset_dim&#39; in out.keys(), &#39;Error, duplicate crossings detected.&#39;

    # Identify points where no LFC intersections were found.
    lfc_missing = np.isnan(intersections.increasing_x.max(dim=&#39;offset_dim&#39;))

    # If no intersection was found, but a parcel temperature above the LCL is greater than the
    # environmental temperature, return the LCL.
    above_lcl = profile.pressure &lt; profile.lcl_pressure
    pos_parcel = ((profile.temperature.where(above_lcl) &gt; 
                   profile.environment_temperature.where(above_lcl)).any(dim=vert_dim))
    no_lfc_pos_parcel = np.logical_and(pos_parcel, lfc_missing)

    # Also return LCL if an intersection exists but all intersections are below the LCL
    # and EL is above the LCL.
    exists_but_na = np.logical_and(np.logical_not(lfc_missing), np.isnan(out.lfc_pressure))
    el_above_lcl = out.el_pressure &lt; profile.lcl_pressure
    lfc_below_el_above = np.logical_and(exists_but_na, el_above_lcl)
    
    # Do the replacements with LCL.
    replace_with_lcl = np.logical_or(no_lfc_pos_parcel, lfc_below_el_above)
    out[&#39;lfc_pressure&#39;] = profile.lcl_pressure.where(replace_with_lcl, other=out.lfc_pressure)
    out[&#39;lfc_temperature&#39;] = profile.lcl_temperature.where(replace_with_lcl, other=out.lfc_temperature)   
    
    # Assign metadata.
    out.el_pressure.attrs[&#39;long_name&#39;] = &#39;Equilibrium level pressure&#39;
    out.el_pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
    out.el_temperature.attrs[&#39;long_name&#39;] = &#39;Equilibrium level temperature&#39;
    out.el_temperature.attrs[&#39;units&#39;] = &#39;K&#39;
    out.lfc_pressure.attrs[&#39;long_name&#39;] = &#39;Level of free convection pressure&#39;
    out.lfc_pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
    out.lfc_temperature.attrs[&#39;long_name&#39;] = &#39;Level of free convection temperature&#39;
    out.lfc_temperature.attrs[&#39;units&#39;] = &#39;K&#39;

    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.lifted_index"><code class="name flex">
<span>def <span class="ident">lifted_index</span></span>(<span>profile, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the lifted index. </p>
<p>Lifted index formula derived from Galway 1956 and referenced by DoswellSchultz 2006.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>profile: Profile as returned by parcel_profile_with_lcl().</li>
<li>vert_dim: The vertical dimension name.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Lifted index at each point [K].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lifted_index(profile, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate the lifted index. 
    
    Lifted index formula derived from Galway 1956 and referenced by DoswellSchultz 2006.

    Arguments:
        - profile: Profile as returned by parcel_profile_with_lcl().
        - vert_dim: The vertical dimension name.

    Returns:

        - Lifted index at each point [K].
    &#34;&#34;&#34;
    
    # Interpolate (linearly) to get 500 hPa values.
    dat = linear_interp(x=profile, coords=profile.pressure, at=500, dim=vert_dim)
    dat = dat.reset_coords(drop=True)
    
    # Calculate lifted index.
    li = xarray.Dataset({&#39;lifted_index&#39;: dat.environment_temperature - dat.temperature})
    li.lifted_index.attrs[&#39;long_name&#39;] = &#39;Lifted index&#39;
    li.lifted_index.attrs[&#39;units&#39;] = &#39;K&#39;
    
    return li</code></pre>
</details>
</dd>
<dt id="parcel_functions.linear_interp"><code class="name flex">
<span>def <span class="ident">linear_interp</span></span>(<span>x, coords, at, dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Perform simple linear interpolation to get values at specified points.</p>
<h2 id="arguments">Arguments</h2>
<p>x: Data set to interpolate.
coords: Coordinate value for each point in x.
at: Points at which to interpolate.
dim: The dimension along which to interpolate.</p>
<p>It is assumed that x[coords] is sorted and does not contain duplicate
values along the selected dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_interp(x, coords, at, dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Perform simple linear interpolation to get values at specified points.
    
    Arguments:
        x: Data set to interpolate.
        coords: Coordinate value for each point in x.
        at: Points at which to interpolate.
        dim: The dimension along which to interpolate.
    
    It is assumed that x[coords] is sorted and does not contain duplicate 
    values along the selected dimension.
    &#34;&#34;&#34;
    
    coords_before = coords.where(coords &gt;= at).min(dim=dim)
    coords_after = coords.where(coords &lt;= at).max(dim=dim)
    assert dim not in coords_before.coords, &#39;Duplicates detected in coords.&#39;
    assert dim not in coords_after.coords, &#39;Duplicates detected in coords.&#39;

    x_before = x.where(coords == coords_before).max(dim=dim)
    x_after = x.where(coords == coords_after).max(dim=dim)

    # The interpolated values.
    res = x_before + (x_after - x_before) * ((at - coords_before) / (coords_after - coords_before))
    
    # When the interpolated x exists already, return it.
    res = x_before.where(x_before == x_after, other=res)
    
    return(res)</code></pre>
</details>
</dd>
<dt id="parcel_functions.log_interp"><code class="name flex">
<span>def <span class="ident">log_interp</span></span>(<span>x, coords, at, dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Run linear_interp on logged coordinate values.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>x: Data set to interpolate.</li>
<li>coords: Coordinate value for each point in x.</li>
<li>at: Points at which to interpolate.</li>
<li>dim: The dimension along which to interpolate.</li>
</ul>
<p>It is assumed that x[coords] is sorted and does not contain duplicate
values along the selected dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_interp(x, coords, at, dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Run linear_interp on logged coordinate values.
    
    Arguments:
        - x: Data set to interpolate.
        - coords: Coordinate value for each point in x.
        - at: Points at which to interpolate.
        - dim: The dimension along which to interpolate.
    
    It is assumed that x[coords] is sorted and does not contain duplicate 
    values along the selected dimension.
    &#34;&#34;&#34;
    
    return linear_interp(x=x, coords=np.log(coords), at=np.log(at), dim=dim)</code></pre>
</details>
</dd>
<dt id="parcel_functions.mixed_layer"><code class="name flex">
<span>def <span class="ident">mixed_layer</span></span>(<span>dat, depth=100, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Mix variable(s) over a layer, yielding a mass-weighted average.</p>
<p>Integrate a data variable with respect to pressure and determine the
average value using the mean value theorem.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>dat: The DataArray to mix. Must contain pressure and variables.</li>
<li>bottom: Pressure above the surface pressure to start from [hPa].</li>
<li>depth: Depth above the bottom of the layer to mix [hPa].</li>
<li>vert_dim: The name of the vertical dimension.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>xarray with mixed values of each data variable.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mixed_layer(dat, depth=100, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Mix variable(s) over a layer, yielding a mass-weighted average.

    Integrate a data variable with respect to pressure and determine the
    average value using the mean value theorem.

    Arguments:
        - dat: The DataArray to mix. Must contain pressure and variables.
        - bottom: Pressure above the surface pressure to start from [hPa].
        - depth: Depth above the bottom of the layer to mix [hPa].
        - vert_dim: The name of the vertical dimension.

    Returns:

        - xarray with mixed values of each data variable.
    &#34;&#34;&#34;
    
    layer = get_layer(dat=dat, depth=depth, drop=True)
    
    pressure_depth = np.abs(layer.pressure.min(vert_dim) - 
                            layer.pressure.max(vert_dim))
   
    ret = (1. / pressure_depth) * trapz(dat=layer, x=&#39;pressure&#39;, dim=vert_dim)
    return ret</code></pre>
</details>
</dd>
<dt id="parcel_functions.mixed_layer_cape_cin"><code class="name flex">
<span>def <span class="ident">mixed_layer_cape_cin</span></span>(<span>pressure, temperature, dewpoint, moist_adiabat_lookup, moist_adiabats, vert_dim='model_level_number', depth=100, return_profile=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate CAPE and CIN for a fully-mixed lowest x hPa parcel.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure level(s) of interest [hPa].</li>
<li>temperature: Temperature at each pressure level [K].</li>
<li>moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by
moist_adiabat_tables().</li>
<li>dewpoint: Dewpoint at each level [K].</li>
<li>vert_dim: The vertical dimension.</li>
<li>depth: The depth above the surface (lowest-level pressure) to mix [hPa].</li>
<li>return_profile: Also return the lifted profile?</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset with convective available potential energy (cape) and
convective inhibition (cin), both in J kg-1.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mixed_layer_cape_cin(pressure, temperature, dewpoint, moist_adiabat_lookup, moist_adiabats, 
                         vert_dim=&#39;model_level_number&#39;, depth=100, return_profile=False):
    &#34;&#34;&#34;
    Calculate CAPE and CIN for a fully-mixed lowest x hPa parcel.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - dewpoint: Dewpoint at each level [K].
        - vert_dim: The vertical dimension.
        - depth: The depth above the surface (lowest-level pressure) to mix [hPa].
        - return_profile: Also return the lifted profile?
        
    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;

    # Mix the lowest x hPa.
    mp = mixed_parcel(pressure=pressure, temperature=temperature, 
                      dewpoint=dewpoint, depth=depth)
    
    # Remove layers that were part of the mixed layer.
    higher_levels = pressure &lt; (pressure.max(dim=vert_dim) - depth)
    pressure = shift_out_nans(pressure.where(higher_levels, drop=True), dim=vert_dim)
    temperature = shift_out_nans(temperature.where(higher_levels, drop=True), dim=vert_dim)
    
    # Add the mixed layer to the bottom of the profiles.
    mp[vert_dim] = pressure[vert_dim].min() - 1
    pressure = xarray.concat([mp.pressure, pressure], dim=vert_dim)
    temperature = xarray.concat([mp.temperature, temperature], dim=vert_dim)
        
    return cape_cin(pressure=pressure,
                    temperature=temperature,
                    parcel_temperature=mp.temperature, 
                    parcel_pressure=mp.pressure,
                    parcel_dewpoint=mp.dewpoint,
                    moist_adiabat_lookup=moist_adiabat_lookup, 
                    moist_adiabats=moist_adiabats, 
                    vert_dim=vert_dim,
                    return_profile=return_profile)</code></pre>
</details>
</dd>
<dt id="parcel_functions.mixed_parcel"><code class="name flex">
<span>def <span class="ident">mixed_parcel</span></span>(<span>pressure, temperature, dewpoint, depth=100, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Fully mix a layer of given depth above the surface and find the temparature,
pressure and dewpoint of the parcel.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure by level [hPa].</li>
<li>temperature: Temperature at each level [K].</li>
<li>dewpoint: Dewpoint at each level [K].</li>
<li>depth: Depth above the surface to mix [hPa].</li>
<li>vert_dim: The name of the vertical dimension.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>DataArray with mixed parcel pressure [hPa], temperature [K] and dewpoint [K].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mixed_parcel(pressure, temperature, dewpoint, depth=100, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Fully mix a layer of given depth above the surface and find the temparature, 
    pressure and dewpoint of the parcel.

    Arguments:
        - pressure: Pressure by level [hPa].
        - temperature: Temperature at each level [K].
        - dewpoint: Dewpoint at each level [K].
        - depth: Depth above the surface to mix [hPa].
        - vert_dim: The name of the vertical dimension.

    Returns:

        - DataArray with mixed parcel pressure [hPa], temperature [K] and dewpoint [K].
    &#34;&#34;&#34;
    
    # Use the surface (lowest level) pressure as the start of the layer to mix.
    parcel_start_pressure = pressure.isel({vert_dim: 0})

    # Calculate the potential temperature over the layer.
    theta = metpy.calc.potential_temperature(pressure, temperature)
    theta = theta.metpy.dequantify()
    theta.name = &#39;theta&#39;
    
    # Mixing ratio over the layer.
    mixing_ratio = metpy.calc.saturation_mixing_ratio(pressure, dewpoint)
    mixing_ratio = mixing_ratio.metpy.dequantify()
    mixing_ratio.name = &#39;mixing_ratio&#39;
    
    # Mix theta and mixing ratio over the layer.
    assert pressure.name is not None, &#39;pressure requires name pressure.&#39;
    mp = mixed_layer(xarray.merge([pressure, theta, mixing_ratio]), depth=depth)
        
    # Convert potential temperature back to temperature.
    mp[&#39;temperature&#39;] = mp.theta * metpy.calc.exner_function(parcel_start_pressure)
    mp[&#39;temperature&#39;] = mp.temperature.metpy.dequantify()
    mp.temperature.attrs[&#39;long_name&#39;] = &#39;Mixed parcel temperature&#39;
    mp.temperature.attrs[&#39;units&#39;] = &#39;K&#39;

    # Convert mixing ratio back to dewpoint.
    mp[&#39;vapour_pressure&#39;] = metpy.calc.vapor_pressure(parcel_start_pressure, mp.mixing_ratio)
    mp[&#39;vapour_pressure&#39;] = mp.vapour_pressure.metpy.dequantify()
    mp.vapour_pressure.attrs[&#39;long_name&#39;] = &#39;Mixed-parcel vapour pressure&#39;
    
    mp[&#39;dewpoint&#39;] = metpy.calc.dewpoint(mp.vapour_pressure).metpy.convert_units(&#39;K&#39;)
    mp[&#39;dewpoint&#39;] = mp.dewpoint.metpy.dequantify()
    mp.dewpoint.attrs[&#39;long_name&#39;] = &#39;Mixed-parcel dewpoint&#39;
    
    # For pressure, use the starting pressure for the layer (following MetPy&#39;s 
    # mixed_parcel function).
    mp[&#39;pressure&#39;] = parcel_start_pressure 
    
    return mp</code></pre>
</details>
</dd>
<dt id="parcel_functions.moist_adiabat_lookup"><code class="name flex">
<span>def <span class="ident">moist_adiabat_lookup</span></span>(<span>pressure_levels=array([1.1000e+03, 1.0995e+03, 1.0990e+03, ..., 1.5000e+00, 1.0000e+00,
5.0000e-01]), temperatures=array([173.
, 173.02, 173.04, ..., 315.94, 315.96, 315.98]), pres_step=0.5, temp_step=0.02)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moist adiabat lookup tables.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure_levels: Pressure levels to keep in adiabat lookup table [hPa].</li>
<li>temperatures: Temperatures to keep in adiabat lookup table [K].</li>
<li>pres_step, temp_step: (Positive) step size for pressure_levels and
temperatures, respectively.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>two DataArrays: 1) a lookup table of pressure/temperature vs. adiabat number,
and 2) a lookup table of adiabat number to temperature by pressure profiles.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moist_adiabat_lookup(pressure_levels=np.round(np.arange(1100, 0, step=-0.5), 1),
                         temperatures=np.round(np.arange(173, 316, step=0.02), 2),
                         pres_step=0.5, temp_step=0.02):
    &#34;&#34;&#34;
    Calculate moist adiabat lookup tables.
    
    Arguments:
        - pressure_levels: Pressure levels to keep in adiabat lookup table [hPa].
        - temperatures: Temperatures to keep in adiabat lookup table [K].
        - pres_step, temp_step: (Positive) step size for pressure_levels and 
                              temperatures, respectively.
                              
    Returns:
        - two DataArrays: 1) a lookup table of pressure/temperature vs. adiabat number, 
             and 2) a lookup table of adiabat number to temperature by pressure profiles.
    &#34;&#34;&#34;
        
    curves = []
    adiabat_lookup = xarray.Dataset({&#39;adiabat&#39;: np.nan})
    adiabat_lookup = adiabat_lookup.expand_dims({&#39;pressure&#39;: pressure_levels, 
                                                 &#39;temperature&#39;: temperatures}).copy(deep=True)
    
    # Find the adiabat for each starting temperature.
    i = 1
    for parcel_temperature in temperatures:
        for offset in [0, temp_step/2]:
            profile_temps = metpy.calc.moist_lapse(pressure=pressure_levels*units.hPa, 
                                                   temperature=(parcel_temperature+offset)*units.K).m

            nearest_temps = round_to(profile_temps, temp_step)
            idx = np.isin(nearest_temps, temperatures)
            temp_idx = xarray.DataArray(nearest_temps[idx], dims=[&#39;idx&#39;])
            pres_idx = xarray.DataArray(pressure_levels[idx], dims=[&#39;idx&#39;])
            adiabat_lookup.adiabat.loc[{&#39;pressure&#39;:pres_idx, &#39;temperature&#39;: temp_idx}] = i

            # In profile_temps we have the adiabat temperature for every pressure level.
            # But some temperatures in the lookup table may be missing. Interpolate the 
            # pressures for each required temperature.
            pres_per_temp = np.interp(x=temperatures, xp=profile_temps[::-1], 
                                      fp=pressure_levels[::-1], right=np.nan, left=np.nan)

            pres_per_temp = round_to(pres_per_temp, pres_step)
            idx = np.isin(pres_per_temp, pressure_levels)
            pres_idx = xarray.DataArray(pres_per_temp[idx], dims=[&#39;idx&#39;])
            temp_idx = xarray.DataArray(temperatures[idx], dims=[&#39;idx&#39;])
            adiabat_lookup.adiabat.loc[{&#39;pressure&#39;:pres_idx, &#39;temperature&#39;: temp_idx}] = i

            # curves contains the adiabats themselves.
            curves.append(xarray.Dataset({&#39;temperature&#39;: ([&#39;pressure&#39;], profile_temps)}, 
                                         coords={&#39;pressure&#39;: pressure_levels}))
            curves[-1][&#39;adiabat&#39;] = i
            i = i + 1

    # Combine curves into one dataset.
    adiabats = xarray.combine_nested(curves, concat_dim=&#39;adiabat&#39;)
        
    for x in [adiabat_lookup, adiabats]:
        x.pressure.attrs[&#39;long_name&#39;] = &#39;Pressure&#39;
        x.pressure.attrs[&#39;units&#39;] = &#39;hPa&#39;
        x.temperature.attrs[&#39;long_name&#39;] = &#39;Temperature&#39;
        x.temperature.attrs[&#39;units&#39;] = &#39;K&#39;
        x.adiabat.attrs[&#39;long_name&#39;] = &#39;Adiabat index&#39;
        
    return adiabat_lookup, adiabats</code></pre>
</details>
</dd>
<dt id="parcel_functions.moist_adiabat_tables"><code class="name flex">
<span>def <span class="ident">moist_adiabat_tables</span></span>(<span>regenerate=False, cache=True, lookup_cache='lookup_tables/moist_adiabat_lookup.nc', adiabats_cache='lookup_tables/adiabats_cache.nc', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moist adiabat lookup tables.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>regenerate: Calculate from scratch and save caches?</li>
<li>cache: Write cache files?</li>
<li>lookup_cache: A cache file (nc) for the adiabat lookup table.</li>
<li>adiabats_cache: A cache file (nc) for the adiabats cache.</li>
<li>**kwargs: Keyword arguments to moist_adiabat_lookup().</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>two DataArrays: 1) a lookup table of pressure/temperature vs. adiabat number,
and 2) a lookup table of adiabat number to temperature by pressure profiles.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moist_adiabat_tables(regenerate=False, cache=True,
                         lookup_cache=&#39;lookup_tables/moist_adiabat_lookup.nc&#39;,
                         adiabats_cache=&#39;lookup_tables/adiabats_cache.nc&#39;,
                         **kwargs):
    &#34;&#34;&#34;
    Calculate moist adiabat lookup tables.
    
    Arguments:
        - regenerate: Calculate from scratch and save caches?
        - cache: Write cache files?
        - lookup_cache: A cache file (nc) for the adiabat lookup table.
        - adiabats_cache: A cache file (nc) for the adiabats cache.
        - **kwargs: Keyword arguments to moist_adiabat_lookup().
                           
    Returns:

        - two DataArrays: 1) a lookup table of pressure/temperature vs. adiabat number, 
             and 2) a lookup table of adiabat number to temperature by pressure profiles.
    &#34;&#34;&#34;
    
    if not regenerate:
        adiabat_lookup = xarray.open_dataset(lookup_cache)
        adiabats = xarray.open_dataset(adiabats_cache)
        return adiabat_lookup, adiabats
    
    # Generate lookup tables.
    adiabat_lookup, adiabats = moist_adiabat_lookup(**kwargs)
    
    if cache:
        adiabats.to_netcdf(adiabats_cache)
        adiabat_lookup.to_netcdf(lookup_cache)
        
    return adiabat_lookup, adiabats</code></pre>
</details>
</dd>
<dt id="parcel_functions.moist_lapse"><code class="name flex">
<span>def <span class="ident">moist_lapse</span></span>(<span>pressure, parcel_temperature, moist_adiabat_lookup, moist_adiabats, parcel_pressure=None, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Return the temperature of parcels raised moist-adiabatically (assuming liquid saturation processes).
Note: What is returned are approximate pseudo-adiabatic moist lapse rates, found using a lookup table.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Atmospheric pressure(s) to lift the parcel to [hPa].</li>
<li>parcel_temperature: Temperature(s) of parcels to lift [K].</li>
<li>moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by moist_adiabat_tables().</li>
<li>parcel_pressure: Parcel pressure before lifting. Defaults to vertical maximum.</li>
<li>vert_dim: The name of the vertical dimension.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Parcel temperature at each pressure level.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moist_lapse(pressure, parcel_temperature, moist_adiabat_lookup, moist_adiabats,
                parcel_pressure=None, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Return the temperature of parcels raised moist-adiabatically (assuming liquid saturation processes).
    Note: What is returned are approximate pseudo-adiabatic moist lapse rates, found using a lookup table.

    Arguments:
        - pressure: Atmospheric pressure(s) to lift the parcel to [hPa].
        - parcel_temperature: Temperature(s) of parcels to lift [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by moist_adiabat_tables().
        - parcel_pressure: Parcel pressure before lifting. Defaults to vertical maximum.
        - vert_dim: The name of the vertical dimension.

    Returns:

        - Parcel temperature at each pressure level.
    &#34;&#34;&#34;

    if parcel_pressure is None:
        parcel_pressure = pressure.max(vert_dim)
        
    # For each starting parcel, find the moist adiabat that intersects the parcel pressure 
    # and temperature.
    adiabat_idx = moist_adiabat_lookup.sel({&#39;pressure&#39;: parcel_pressure, 
                                            &#39;temperature&#39;: parcel_temperature}, method=&#39;nearest&#39;)
    adiabat_idx = adiabat_idx.adiabat.reset_coords(drop=True)
    adiabats = moist_adiabats.sel(adiabat=adiabat_idx)
    
    # Interpolate the adiabat to get the temperature at each requested pressure.
    out = adiabats.temperature.interp({&#39;pressure&#39;: pressure}).reset_coords(drop=True)
    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.most_unstable_cape_cin"><code class="name flex">
<span>def <span class="ident">most_unstable_cape_cin</span></span>(<span>pressure, temperature, dewpoint, moist_adiabat_lookup, moist_adiabats, vert_dim='model_level_number', depth=300, return_profile=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate CAPE and CIN for the most unstable parcel within a given
depth above the surface..</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure level(s) of interest [hPa].</li>
<li>temperature: Temperature at each pressure level [K].</li>
<li>moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by
moist_adiabat_tables().</li>
<li>dewpoint: Dewpoint at each level [K].</li>
<li>vert_dim: The vertical dimension.</li>
<li>depth: The depth above the surface (lowest-level pressure) in which to
look for the most unstable parcel.</li>
<li>return_profile: Also return the lifted profile?</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset with convective available potential energy (cape) and
convective inhibition (cin), both in J kg-1.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def most_unstable_cape_cin(pressure, temperature, dewpoint, moist_adiabat_lookup, moist_adiabats, 
                           vert_dim=&#39;model_level_number&#39;, depth=300, return_profile=False):
    &#34;&#34;&#34;
    Calculate CAPE and CIN for the most unstable parcel within a given 
    depth above the surface..

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - dewpoint: Dewpoint at each level [K].
        - vert_dim: The vertical dimension.
        - depth: The depth above the surface (lowest-level pressure) in which to 
                 look for the most unstable parcel.
        - return_profile: Also return the lifted profile?
        
    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;
    
    assert pressure.name == &#39;pressure&#39;, &#39;Pressure requires name pressure.&#39;
    assert temperature.name == &#39;temperature&#39;, &#39;Temperature requires name temperature.&#39;
    assert dewpoint.name == &#39;dewpoint&#39;, &#39;Dewpoint requires name dewpoint.&#39;
        
    # Find the most unstable layer in the lowest &#39;depth&#39; hPa.
    unstable_layer = most_unstable_parcel(dat=xarray.merge([pressure, temperature, dewpoint]), 
                                          depth=depth, vert_dim=vert_dim)
        
    # Subset to layers at or above the most unstable parcels.
    above_unstable = pressure &lt;= unstable_layer.pressure
    pressure = shift_out_nans(pressure.where(above_unstable, drop=True), dim=vert_dim)
    temperature = shift_out_nans(temperature.where(above_unstable, drop=True), dim=vert_dim)
        
    return cape_cin(pressure=pressure,
                    temperature=temperature,
                    parcel_temperature=unstable_layer.temperature, 
                    parcel_pressure=unstable_layer.pressure,
                    parcel_dewpoint=unstable_layer.dewpoint,
                    moist_adiabat_lookup=moist_adiabat_lookup, 
                    moist_adiabats=moist_adiabats,
                    vert_dim=vert_dim,
                    return_profile=return_profile)    </code></pre>
</details>
</dd>
<dt id="parcel_functions.most_unstable_parcel"><code class="name flex">
<span>def <span class="ident">most_unstable_parcel</span></span>(<span>dat, depth=300, drop=False, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Return the most unstable parcel with an atmospheric layer from with the
requested bottom and depth. No interpolation is performed.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>dat: DataArray, must contain pressure, temperature, and dewpoint.</li>
<li>bottom: Pressure level to start from [hPa].</li>
<li>depth: Depth above the bottom of the layer to mix [hPa].</li>
<li>drop: Drop unselected elements?</li>
<li>vert_dim: Vertical dimension name.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>xarray DataArray with pressure and data variables for the layer.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def most_unstable_parcel(dat, depth=300, drop=False, vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Return the most unstable parcel with an atmospheric layer from with the 
    requested bottom and depth. No interpolation is performed.

    Arguments:
        - dat: DataArray, must contain pressure, temperature, and dewpoint.
        - bottom: Pressure level to start from [hPa].
        - depth: Depth above the bottom of the layer to mix [hPa].
        - drop: Drop unselected elements?
        - vert_dim: Vertical dimension name.

    Returns:

        - xarray DataArray with pressure and data variables for the layer.
    &#34;&#34;&#34;

    layer = get_layer(dat=dat, depth=depth, drop=drop, vert_dim=vert_dim, interpolate=False)
    eq = metpy.calc.equivalent_potential_temperature(pressure=layer.pressure,
                                                     temperature=layer.temperature,
                                                     dewpoint=layer.dewpoint).metpy.dequantify()
    max_eq = eq.max(dim=vert_dim)
    assert np.all(eq.where(eq == max_eq).count(vert_dim) == 1), &#39;Multiple maximum eq values.&#39;
    most_unstable = layer.where(eq == max_eq).max(dim=vert_dim, keep_attrs=True)
    return most_unstable</code></pre>
</details>
</dd>
<dt id="parcel_functions.parcel_profile"><code class="name flex">
<span>def <span class="ident">parcel_profile</span></span>(<span>pressure, parcel_pressure, parcel_temperature, parcel_dewpoint, moist_adiabat_lookup, moist_adiabats)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate temperatures of a lifted parcel.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure levels to calculate on [hPa].</li>
<li>parcel_pressure: Pressure of the parcel [hPa].</li>
<li>parcel_temperature: Temperature of the parcel [K].</li>
<li>parcel_dewpoint: Dewpoint of the parcel [K].</li>
<li>moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by moist_adiabat_tables().</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset with the temperature of the parcel lifted from parcel_pressure to
levels in pressures, plus the LCL pressure and temperature.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parcel_profile(pressure, parcel_pressure, parcel_temperature, parcel_dewpoint, 
                   moist_adiabat_lookup, moist_adiabats):
    &#34;&#34;&#34;
    Calculate temperatures of a lifted parcel.
    
    Arguments:
        - pressure: Pressure levels to calculate on [hPa].
        - parcel_pressure: Pressure of the parcel [hPa].
        - parcel_temperature: Temperature of the parcel [K].
        - parcel_dewpoint: Dewpoint of the parcel [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by moist_adiabat_tables().
  
    Returns:

        - Dataset with the temperature of the parcel lifted from parcel_pressure to 
          levels in pressures, plus the LCL pressure and temperature.
    &#34;&#34;&#34;
       
    out = xarray.Dataset()
    out[&#39;pressure&#39;] = pressure

    # Find the LCL for the selected parcel.
    out = xarray.merge([out, lcl(parcel_pressure=parcel_pressure, 
                                 parcel_temperature=parcel_temperature, 
                                 parcel_dewpoint=parcel_dewpoint)])

    # Parcels are raised along the dry adiabats from the starting point to the LCL.
    below_lcl = dry_lapse(pressure=pressure, 
                          parcel_temperature=parcel_temperature, 
                          parcel_pressure=parcel_pressure)

    # Above the LCL parcels follow the moist adiabats from the LCL temp/pressure.
    above_lcl = moist_lapse(pressure=pressure, 
                            parcel_temperature=out.lcl_temperature,
                            parcel_pressure=out.lcl_pressure,
                            moist_adiabat_lookup=moist_adiabat_lookup,
                            moist_adiabats=moist_adiabats)

    out[&#39;temperature&#39;] = below_lcl.where(pressure &gt;= out.lcl_pressure, other=above_lcl)
    out.temperature.attrs[&#39;long_name&#39;] = &#39;Lifted parcel temperature&#39;
    out.temperature.attrs[&#39;units&#39;] = &#39;K&#39;

    out = out.reset_coords(drop=True)
    return out</code></pre>
</details>
</dd>
<dt id="parcel_functions.parcel_profile_with_lcl"><code class="name flex">
<span>def <span class="ident">parcel_profile_with_lcl</span></span>(<span>pressure, temperature, parcel_pressure, parcel_temperature, parcel_dewpoint, moist_adiabat_lookup, moist_adiabats, vert_dim='model_level_number')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate temperatures of a lifted parcel, including at the lcl.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure levels to calculate on [hPa].</li>
<li>temperature: Temperature at each pressure level [K].</li>
<li>parcel_pressure: Pressure of the parcel [hPa].</li>
<li>parcel_temperature: Temperature of the parcel [K].</li>
<li>parcel_dewpoint: Dewpoint of the parcel [K].</li>
<li>moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by
moist_adiabat_tables().</li>
<li>vert_dim: The name of the vertical dimension.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset with the temperature of the parcel lifted from parcel_pressure to
levels in pressures, including the LCL, plus the LCL pressure and temperature, and
environmental temperature including at the LCL.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parcel_profile_with_lcl(pressure, temperature, parcel_pressure, parcel_temperature, 
                            parcel_dewpoint, moist_adiabat_lookup, moist_adiabats,
                            vert_dim=&#39;model_level_number&#39;):
    &#34;&#34;&#34;
    Calculate temperatures of a lifted parcel, including at the lcl.
    
    Arguments:
        - pressure: Pressure levels to calculate on [hPa].
        - temperature: Temperature at each pressure level [K].
        - parcel_pressure: Pressure of the parcel [hPa].
        - parcel_temperature: Temperature of the parcel [K].
        - parcel_dewpoint: Dewpoint of the parcel [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                              moist_adiabat_tables().
        - vert_dim: The name of the vertical dimension.
  
    Returns:

         - Dataset with the temperature of the parcel lifted from parcel_pressure to 
             levels in pressures, including the LCL, plus the LCL pressure and temperature, and
             environmental temperature including at the LCL.
    &#34;&#34;&#34;
    
    profile = parcel_profile(pressure=pressure, parcel_pressure=parcel_pressure, 
                             parcel_temperature=parcel_temperature,
                             parcel_dewpoint=parcel_dewpoint, 
                             moist_adiabat_lookup=moist_adiabat_lookup, 
                             moist_adiabats=moist_adiabats)
    return add_lcl_to_profile(profile=profile, vert_dim=vert_dim, temperature=temperature)</code></pre>
</details>
</dd>
<dt id="parcel_functions.round_to"><code class="name flex">
<span>def <span class="ident">round_to</span></span>(<span>x, to, dp=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Round x to the nearest 'to' and return rounded to 'dp' decimal points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_to(x, to, dp=2):
    &#34;&#34;&#34;
    Round x to the nearest &#39;to&#39; and return rounded to &#39;dp&#39; decimal points.
    &#34;&#34;&#34;
    return np.round(np.round(x / to) * to, dp)</code></pre>
</details>
</dd>
<dt id="parcel_functions.shift_out_nans"><code class="name flex">
<span>def <span class="ident">shift_out_nans</span></span>(<span>x, dim, pt=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Shift data along a dim to remove all leading nans in that dimension, element-wise.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>x: The data to work on.</li>
<li>dim: The dimension to shift.</li>
<li>pt: The point along the dimension to shift 'to'.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift_out_nans(x, dim, pt=0):
    &#34;&#34;&#34;
    Shift data along a dim to remove all leading nans in that dimension, element-wise.
    
    Arguments:
        - x: The data to work on.
        - dim: The dimension to shift.
        - pt: The point along the dimension to shift &#39;to&#39;.
    &#34;&#34;&#34;
    
    while np.any(np.isnan(x.isel({dim: pt}))):
        shifted = x.shift({dim: -1})
        x = shifted.where(np.isnan(x.isel({dim: pt})), other=x)
        
    return x</code></pre>
</details>
</dd>
<dt id="parcel_functions.surface_based_cape_cin"><code class="name flex">
<span>def <span class="ident">surface_based_cape_cin</span></span>(<span>pressure, temperature, dewpoint, moist_adiabat_lookup, moist_adiabats, vert_dim='model_level_number', return_profile=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate surface-based CAPE and CIN.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>pressure: Pressure level(s) of interest [hPa].</li>
<li>temperature: Temperature at each pressure level [K].</li>
<li>dewpoint: Dewpoint at each level [K].</li>
<li>moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by
moist_adiabat_tables().</li>
<li>vert_dim: The vertical dimension.</li>
<li>return_profile: Also return the lifted profile?</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dataset with convective available potential energy (cape) and
convective inhibition (cin), both in J kg-1.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surface_based_cape_cin(pressure, temperature, dewpoint, moist_adiabat_lookup, 
                           moist_adiabats, vert_dim=&#39;model_level_number&#39;, return_profile=False):
    &#34;&#34;&#34;
    Calculate surface-based CAPE and CIN.

    Arguments:
        - pressure: Pressure level(s) of interest [hPa].
        - temperature: Temperature at each pressure level [K].
        - dewpoint: Dewpoint at each level [K].
        - moist_adiabat_lookup, moist_adiabats: Adiabat lookup tables generated by 
                                                moist_adiabat_tables().
        - vert_dim: The vertical dimension.
        - return_profile: Also return the lifted profile?
        
    Returns:

        - Dataset with convective available potential energy (cape) and 
          convective inhibition (cin), both in J kg-1.
    &#34;&#34;&#34;
    
    # Profile for surface-based parcel ascent.
    return cape_cin(pressure=pressure,
                    temperature=temperature,
                    parcel_temperature=temperature.isel({vert_dim: 0}),
                    parcel_pressure=pressure.isel({vert_dim: 0}),
                    parcel_dewpoint=dewpoint.isel({vert_dim: 0}),
                    moist_adiabat_lookup=moist_adiabat_lookup, 
                    moist_adiabats=moist_adiabats,
                    vert_dim=vert_dim,
                    return_profile=return_profile)</code></pre>
</details>
</dd>
<dt id="parcel_functions.trap_around_zeros"><code class="name flex">
<span>def <span class="ident">trap_around_zeros</span></span>(<span>x, y, dim, log_x=True, start=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate dx * y for points just before and after zeros in y.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>x: arrays of x along dim.</li>
<li>y: arrays of y along dim.</li>
<li>dim: Dimension along which to calculate.</li>
<li>log_x: Log transform x?</li>
<li>start: Zero-based position along dim to look for zeros.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>a Dataset containin the areas and x coordinates for each rectangular area
calculated before and after each zero; and an array of x coordinates that should be
replaced by the new areas if integrating along x and including these areas afterwards.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trap_around_zeros(x, y, dim, log_x=True, start=0):
    &#34;&#34;&#34;
    Calculate dx * y for points just before and after zeros in y.
    
    Arguments:
        - x: arrays of x along dim.
        - y: arrays of y along dim.
        - dim: Dimension along which to calculate.
        - log_x: Log transform x?
        - start: Zero-based position along dim to look for zeros.
        
    Returns:

        - a Dataset containin the areas and x coordinates for each rectangular area 
          calculated before and after each zero; and an array of x coordinates that should be 
          replaced by the new areas if integrating along x and including these areas afterwards.
    &#34;&#34;&#34;
    
    # Estimate zero crossings.
    zeros = xarray.zeros_like(y)
    zero_intersections = find_intersections(x=x.isel({dim: slice(start, None)}), 
                                            a=y.isel({dim: slice(start, None)}),
                                            b=zeros.isel({dim: slice(start, None)}),
                                            dim=dim, log_x=log_x)
    zero_intersections = zero_intersections.rename({&#39;offset_dim&#39;: dim})
    zero_y = zero_intersections.all_intersect_y
    zero_x = zero_intersections.all_intersect_x
        
    # Take log of x if required.
    if log_x:
        x = np.log(x)
        zero_x = np.log(zero_x)
    
    zero_level = xarray.zeros_like(y.isel({dim: 0}))
    
    after_zeros_mask = np.logical_not(np.isnan(zero_y))
    before_zeros_mask = xarray.concat([zero_level, zero_y], dim=dim).shift({dim: -1})
    before_zeros_mask = np.logical_not(np.isnan(before_zeros_mask))
    
    def calc_areas(x, y, mask, shift_x=0):
        areas = xarray.Dataset({&#39;area&#39;: xarray.zeros_like(mask),
                                &#39;dx&#39;: xarray.zeros_like(mask),
                                &#39;x&#39;: xarray.zeros_like(mask)})

        # Get coordinates of zeros.
        x_near_zero = x.where(mask)
        y_near_zero = y.where(mask)
        
        # Determine the value of y (mean of y and zero) and dx.
        mean_y = y_near_zero / 2
        
        dx = x_near_zero.shift({dim:shift_x}) - zero_x
        dx = xarray.concat([zero_level, dx], dim=dim).shift({dim: -shift_x})
    
        areas[&#39;area&#39;] = mean_y * np.abs(dx)
        areas[&#39;x&#39;] = x_near_zero - dx/2
        areas[&#39;dx&#39;] = np.abs(dx)
        areas = areas.dropna(dim=dim, how=&#39;all&#39;).reset_coords(drop=True)
        
        return(areas)
        
    areas_before_zeros = calc_areas(x=x, y=y, mask=before_zeros_mask, shift_x=1)
    areas_after_zeros = calc_areas(x=x, y=y, mask=after_zeros_mask, shift_x=0)
   
    # Concatenate areas before zeros and areas after zeros.
    areas = xarray.concat([areas_before_zeros, areas_after_zeros], dim=dim)
    #areas = areas.assign_coords({dim: np.arange(0, len(areas[dim]))})
    
    # Determine start/end points on x axis for each area.
    areas[&#39;x_from&#39;] = areas.x - areas.dx/2
    areas[&#39;x_to&#39;] = areas.x + areas.dx/2
    
    # Mask is a mask that selects elements that were *not* included in the differences;
    # to be used by a CAPE calculation where we don&#39;t want to count the areas around
    # zeros twice.
    mask = xarray.full_like(x, True)
    mask, bef = xarray.broadcast(mask, areas_before_zeros)
    mask = mask.where(np.isnan(bef.area), other=False)
    
    return areas, mask</code></pre>
</details>
</dd>
<dt id="parcel_functions.trapz"><code class="name flex">
<span>def <span class="ident">trapz</span></span>(<span>dat, x, dim, mask=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform trapezoidal rule integration along an axis, ala numpy.trapz.
Estimates int y dx.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>dat: Data to process.</li>
<li>x: The variable that contains 'x' values along dimension 'dim'.</li>
<li>dim: The dimension along which to integrate 'y' values.</li>
<li>mask: A mask the size of dx/means (ie dim.size-1) for which
areas to include in the integration.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Integrated value along the axis.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trapz(dat, x, dim, mask=None):
    &#34;&#34;&#34; 
    Perform trapezoidal rule integration along an axis, ala numpy.trapz.
    Estimates int y dx.
   
    Arguments:
        - dat: Data to process.
        - x: The variable that contains &#39;x&#39; values along dimension &#39;dim&#39;.
        - dim: The dimension along which to integrate &#39;y&#39; values.
        - mask: A mask the size of dx/means (ie dim.size-1) for which 
                areas to include in the integration.

    Returns:

        - Integrated value along the axis.
    &#34;&#34;&#34;

    dx = np.abs(dat[x].diff(dim))
    dx = dx.reset_coords(drop=True)
    means = dat.rolling({dim: 2}, center=True).mean(keep_attrs=True).dropna(dim, how=&#39;all&#39;)
    means = means.reset_coords(drop=True)

    dx = dx.assign_coords({dim: dx[dim]-1})
    means = means.assign_coords({dim: means[dim]-1})
    
    if mask is not None:
        dx = dx.where(mask)
        means = means.where(mask)
    
    return (dx * means).sum(dim)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="parcel_functions.add_lcl_to_profile" href="#parcel_functions.add_lcl_to_profile">add_lcl_to_profile</a></code></li>
<li><code><a title="parcel_functions.bound_pressure" href="#parcel_functions.bound_pressure">bound_pressure</a></code></li>
<li><code><a title="parcel_functions.cape_cin" href="#parcel_functions.cape_cin">cape_cin</a></code></li>
<li><code><a title="parcel_functions.cape_cin_base" href="#parcel_functions.cape_cin_base">cape_cin_base</a></code></li>
<li><code><a title="parcel_functions.deep_convective_index" href="#parcel_functions.deep_convective_index">deep_convective_index</a></code></li>
<li><code><a title="parcel_functions.dry_lapse" href="#parcel_functions.dry_lapse">dry_lapse</a></code></li>
<li><code><a title="parcel_functions.find_intersections" href="#parcel_functions.find_intersections">find_intersections</a></code></li>
<li><code><a title="parcel_functions.get_layer" href="#parcel_functions.get_layer">get_layer</a></code></li>
<li><code><a title="parcel_functions.insert_level" href="#parcel_functions.insert_level">insert_level</a></code></li>
<li><code><a title="parcel_functions.lcl" href="#parcel_functions.lcl">lcl</a></code></li>
<li><code><a title="parcel_functions.lfc_el" href="#parcel_functions.lfc_el">lfc_el</a></code></li>
<li><code><a title="parcel_functions.lifted_index" href="#parcel_functions.lifted_index">lifted_index</a></code></li>
<li><code><a title="parcel_functions.linear_interp" href="#parcel_functions.linear_interp">linear_interp</a></code></li>
<li><code><a title="parcel_functions.log_interp" href="#parcel_functions.log_interp">log_interp</a></code></li>
<li><code><a title="parcel_functions.mixed_layer" href="#parcel_functions.mixed_layer">mixed_layer</a></code></li>
<li><code><a title="parcel_functions.mixed_layer_cape_cin" href="#parcel_functions.mixed_layer_cape_cin">mixed_layer_cape_cin</a></code></li>
<li><code><a title="parcel_functions.mixed_parcel" href="#parcel_functions.mixed_parcel">mixed_parcel</a></code></li>
<li><code><a title="parcel_functions.moist_adiabat_lookup" href="#parcel_functions.moist_adiabat_lookup">moist_adiabat_lookup</a></code></li>
<li><code><a title="parcel_functions.moist_adiabat_tables" href="#parcel_functions.moist_adiabat_tables">moist_adiabat_tables</a></code></li>
<li><code><a title="parcel_functions.moist_lapse" href="#parcel_functions.moist_lapse">moist_lapse</a></code></li>
<li><code><a title="parcel_functions.most_unstable_cape_cin" href="#parcel_functions.most_unstable_cape_cin">most_unstable_cape_cin</a></code></li>
<li><code><a title="parcel_functions.most_unstable_parcel" href="#parcel_functions.most_unstable_parcel">most_unstable_parcel</a></code></li>
<li><code><a title="parcel_functions.parcel_profile" href="#parcel_functions.parcel_profile">parcel_profile</a></code></li>
<li><code><a title="parcel_functions.parcel_profile_with_lcl" href="#parcel_functions.parcel_profile_with_lcl">parcel_profile_with_lcl</a></code></li>
<li><code><a title="parcel_functions.round_to" href="#parcel_functions.round_to">round_to</a></code></li>
<li><code><a title="parcel_functions.shift_out_nans" href="#parcel_functions.shift_out_nans">shift_out_nans</a></code></li>
<li><code><a title="parcel_functions.surface_based_cape_cin" href="#parcel_functions.surface_based_cape_cin">surface_based_cape_cin</a></code></li>
<li><code><a title="parcel_functions.trap_around_zeros" href="#parcel_functions.trap_around_zeros">trap_around_zeros</a></code></li>
<li><code><a title="parcel_functions.trapz" href="#parcel_functions.trapz">trapz</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>